<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hexo的使用教程</title>
      <link href="/2020/05/15/hexo%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2020/05/15/hexo%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<!-- # hexo的使用教程 --><h3 id="更换主题皮肤"><a href="#更换主题皮肤" class="headerlink" title="更换主题皮肤"></a>更换主题皮肤</h3><pre><code># 下载到themes文件夹下git clone https://github.com/KevinOfNeu/hexo-theme-xoxo themes/xoxo# 修改 _config.yml 配置theme: xoxo</code></pre><h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><pre><code>// [layout] 为布局，可选项为 `post`、`page`、`draft`，这将决定文章所在文件路径。// &lt;title&gt; 为文章标题// 如 hexo new post 除了帅气，我还有啥！hexo new [layout] &lt;title&gt;</code></pre><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="生成“分类”页并添加-tpye-属性"><a href="#生成“分类”页并添加-tpye-属性" class="headerlink" title="生成“分类”页并添加 tpye 属性"></a>生成“分类”页并添加 tpye 属性</h4><p>在项目文件下打开命令行，执行命令</p><pre><code>hexo new page categories</code></pre><p>成功后会提示：</p><pre><code>INFO  Created: ~/Documents/blog/source/categories/index.md</code></pre><p>根据上面的路径，找到index.md这个文件，打开后默认内容是这样的：</p><pre><code>---title: 文章分类date: 2017-05-27 13:47:40---</code></pre><p>添加type: “categories”到内容中，添加后是这样的：</p><pre><code>---title: 文章分类date: 2017-05-27 13:47:40type: &quot;categories&quot;---</code></pre><p>保存并关闭文件。</p><h4 id="给文章添加-“categories”-属性"><a href="#给文章添加-“categories”-属性" class="headerlink" title="给文章添加 “categories” 属性"></a>给文章添加 “categories” 属性</h4><p>打开需要添加分类的文章，为其添加 <code>categories</code> 属性。<br>下方的 <code>categories</code> : web前端 表示添加这篇文章到 “web前端” 这个分类。</p><blockquote><p>注意：<code>hexo</code> 一篇文章只能属于一个分类，也就是说如果在 <code>- web前端</code> 下方添加 <code>-xxx</code>，<code>hexo</code> 不会产生两个分类，而是把分类嵌套（即该文章属于  <code>- web前端</code> 下的  <code>-xxx</code> 分类）。</p></blockquote><pre><code>---title: jQuery对表单的操作及更多应用date: 2020-05-14 12:00:00categories: - web前端---</code></pre><p>至此，成功给文章添加分类，点击首页的分类可以看到该分类下的所有文章。<br>当然，只有添加了 <code>categories: xxx</code> 的文章才会被收录到首页的 分类 中。</p><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><h4 id="生成“标签”页并添加tpye属性"><a href="#生成“标签”页并添加tpye属性" class="headerlink" title="生成“标签”页并添加tpye属性"></a>生成“标签”页并添加tpye属性</h4><p>在项目文件下打开命令行，执行命令</p><pre><code>hexo new page tags</code></pre><p>成功后会提示：</p><pre><code>INFO  Created: ~/Documents/blog/source/tags/index.md</code></pre><p>根据上面的路径，找到index.md这个文件，打开后默认内容是这样的：</p><pre><code>---title: 标签date: 2017-05-27 14:22:08---</code></pre><p>添加type: “categories”到内容中，添加后是这样的：</p><pre><code>---title: 文章分类date: 2017-05-27 13:47:40type: &quot;tags&quot;---</code></pre><p>保存并关闭文件。</p><h4 id="给文章添加-“tags”-属性"><a href="#给文章添加-“tags”-属性" class="headerlink" title="给文章添加 “tags” 属性"></a>给文章添加 “tags” 属性</h4><p>打开需要添加分类的文章，为其添加 <code>tags</code> 属性。<br> <code>tags</code> 下方的:  jQuery   就是这篇文章的标签了 。</p><pre><code>---title: jQuery对表单的操作及更多应用date: 2020-05-14 12:00:00categories: - web前端tags:- jQuery- 表格- 表单验证---</code></pre><p> 至此，成功给文章添加标签，点击首页的 标签 可以看到该标签下的所有文章。<br>当然，只有添加了 <code>tags: xxx</code> 的文章才会被收录到首页的 标签 中。 </p><h3 id="部署优化"><a href="#部署优化" class="headerlink" title="部署优化"></a>部署优化</h3><p> 每次都要执行 <code>hexo clean</code> 和 <code>hexo deploy</code>，不如写个新的脚本 </p><pre><code class="json">// package.json&quot;dev&quot;: &quot;hexo s&quot;,&quot;build&quot;: &quot;hexo clean &amp; hexo deploy&quot;</code></pre><p> 部署命令 </p><pre><code class="js">npm run build</code></pre><p>【参考】</p><p><a href="https://www.cnblogs.com/hankleo/p/11606224.html" target="_blank" rel="noopener">Hexo使用攻略-添加分类及标签</a></p><p><a href="https://www.jianshu.com/p/685bf59cde5e" target="_blank" rel="noopener">为Hexo blog博客创建本地搜索引擎</a></p><p> <a href="https://ysyluminous.github.io/posts/7b55cca4/" target="_blank" rel="noopener">hexo折腾记录</a> </p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Hexo搭建自己的博客</title>
      <link href="/2020/05/15/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/05/15/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<!-- # 使用Hexo搭建自己的博客 --><p>通过hexo快速构建个人博客，并搭建到 <code>github</code> 上供他人访问。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li><p><code>node</code> 环境</p></li><li><p><code>github</code> 账号</p></li></ul><h2 id="如何搭建"><a href="#如何搭建" class="headerlink" title="如何搭建"></a>如何搭建</h2><h3 id="1、新建仓库"><a href="#1、新建仓库" class="headerlink" title="1、新建仓库"></a>1、新建仓库</h3><p> 在 <code>github</code> 上新建一个仓库，仓库名必须为 <code>&lt;user-name&gt;.github.io</code> 格式，其中 <code>&lt;user-name&gt;</code> 是你 <code>github</code> 的昵称。 </p><h3 id="2、全局安装-hexo"><a href="#2、全局安装-hexo" class="headerlink" title="2、全局安装 hexo"></a>2、全局安装 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo</a></h3><pre><code class="node">npm install -g hexo</code></pre><h3 id="3、初始化项目"><a href="#3、初始化项目" class="headerlink" title="3、初始化项目"></a>3、初始化项目</h3><p>在项目文件夹下执行命令 <code>hexo init</code>，就会自动构建一个 <code>hexo</code> 项目，紧接着执行 <code>hexo s</code>，浏览器访问 <code>localhost:4000</code> 就可以看到效果啦！ </p><pre><code>hexo init// 本地运行hexo s</code></pre><h3 id="4、部署到-github"><a href="#4、部署到-github" class="headerlink" title="4、部署到 github"></a>4、部署到 github</h3><p> 快速在项目根目录下找到 <code>_congif.yml</code>，找到 <code>deploy</code> 字段并填写完整 。</p><pre><code># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo: &lt;你的仓库地址&gt; # https://github.com/aye1307/aye1307.github.io  branch: master</code></pre><p> 然后我们需要额外的一个工具来帮助我们推到仓库上，那就是 <code>hexo-deployer-git</code> 。</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>再执行下面两个命令，就可以把项目自动部署到 <code>github</code> 上啦。</p><pre><code>hexo cleanhexo deploy</code></pre><h3 id="5、查看效果"><a href="#5、查看效果" class="headerlink" title="5、查看效果"></a>5、查看效果</h3><p>浏览器访问 <code>https://aye1307.github.io/</code> 即可看到效果。</p><p> 至此，已经完成了个人博客的搭建，也可以在浏览器中访问 。</p><h3 id="6、绑定个人域名"><a href="#6、绑定个人域名" class="headerlink" title="6、绑定个人域名"></a>6、绑定个人域名</h3><ol><li><p>域名与 github page 的配置问题</p><p>在项目仓库中点击 <code>Settings</code>  ，将域名写在 <code>Custom domain</code> 下并保存。会生成一个  <code>CNAME</code> 文件，内容为所填写的域名。<img src="http://qab0509yb.bkt.clouddn.com/Snipaste_2020-05-15_09-45-44.png" alt=""></p></li><li><p>配置域名解析</p></li></ol><p><img src="http://qab0509yb.bkt.clouddn.com/Snipaste_2020-05-15_09-49-17.png" alt=""></p><p> 两者都没配好的时候，访问 <code>userName.github.io</code> 时可能会跳转到 github 的 404 页面。如果两者都对应 <code>ip</code> 地址配置好的，清空本地缓存并多刷新访问，有可能页面缓存或 <code>dns</code> 缓存没刷新。 </p><h2 id="为-hexo-添加-hexo-admin-组件"><a href="#为-hexo-添加-hexo-admin-组件" class="headerlink" title="为 hexo 添加 hexo-admin 组件"></a>为 hexo 添加 hexo-admin 组件</h2><h4 id="插件介绍"><a href="#插件介绍" class="headerlink" title="插件介绍"></a>插件介绍</h4><blockquote><p><a href="https://github.com/jaredly/hexo-admin" target="_blank" rel="noopener"><strong>hexo-admin</strong></a> 是一个 Hexo 博客引擎的管理用户界面插件。这个插件最初是作为本地编辑器设计的，在本地运行 hexo 使用 hexo-admin 编写文章，然后通过 <code>hexo g</code>或 <code>hexo d</code>（<code>hexo g</code> 是本地渲染，<code>hexo d</code> 是将渲染的静态页面发布到 GitHub）将生成的静态页面发布到 GitHub 等静态服务器。如果你使用的是非静态托管服务器，比如自己买的主机搭建的 hexo，那么一定要设置 hexo-admin 的密码，否则谁都可以编辑你的文章。</p></blockquote><h4 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h4><ol><li><p>首先进入 hexo 创建的博客项目的根目录下，执行 </p><pre><code>npm install --save hexo-admin</code></pre><p>mac 和 linux 可能需要 root 权限，前面加个 <code>sudo</code> 就可以了。如果报错缺少组件，则缺少什么安装什么，<code>npm install</code> 加缺少的组件。 </p></li><li><p>运行下列命令启动 hexo-admin： </p><pre><code>hexo server -d</code></pre><p>打开 <a href="http://localhost:4000/admin/" target="_blank" rel="noopener">http://localhost:4000/admin/</a> 就可以访问到 hexo-admin 管理页面了。 </p></li></ol><h4 id="密码保护"><a href="#密码保护" class="headerlink" title="密码保护"></a>密码保护</h4><p> 打开 <code>setting</code>，点击 <code>Setup authentification here</code> 输入用户名，密码，密钥，下面会自动生成配置文件，复制加在 hexo 根目录下的 <code>_config.yml</code> 中： </p><pre><code>admin:  username: aye  password_hash: be121740bf988b2225a313fa1f107ca1  secret: a secret something</code></pre><p> 重启 hexo，就可以看到登录页面了 。</p><h4 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h4><p> 进入后台之后点击<code>Deploy</code>，里面的Deploy按钮是用来执行发布脚本的，所以我们先在博客根目录下新建个目录<code>admin_script</code>，然后在目录中新建一个脚本<code>hexo-g.sh</code>，里面写下下面代码然后保存。</p><pre><code>hexo g &amp;&amp; hexo d</code></pre><p> 然后给hexo-g.sh加入可执行权限 </p><pre><code>chmod +x hexo-d.sh</code></pre><p> 然后在<code>_config.yml</code>中的admin下添加 </p><pre><code>admin:  username: aye  password_hash: be121740bf988b2225a313fa1f107ca1  secret: a secret something  deployCommand: ./admin_script/hexo-d.sh</code></pre><p> 设置发布执行的脚本，点击 <code>Deploy</code> 就会执行这个命令并提交到 GitHub 上。 </p><p>【参考】</p><p> <a href="https://www.jianshu.com/p/390f202c5b0e" target="_blank" rel="noopener">5分钟搞定个人博客-hexo</a> </p><p> <a href="https://blog.csdn.net/RenZouChaLiangrz/article/details/87890621" target="_blank" rel="noopener">为hexo添加hexo-admin组件</a> </p><p><a href="https://www.jianshu.com/p/8d50ff70b3d9" target="_blank" rel="noopener">个人博客搭建 github page绑定域名、https跳转</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序反编译报错</title>
      <link href="/2020/05/13/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99/"/>
      <url>/2020/05/13/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<!-- # 微信小程序反编译报错 --><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​    微信小程序的格式是：<code>.wxapkg</code> ，<code>.wxapkg</code> 是一个二进制文件。详细内容可参考<a href="http://lrdcq.com/me/read.php/66.htm" target="_blank" rel="noopener"> <strong>微信小程序源码阅读笔记</strong> </a></p><p>​    安卓手机目录为 <code>/data/data/com.tencent.mm/MicroMsg/{User}/appbrand/pkg</code></p><p>​    电脑目录为 <code>/WeChat Files/Applet</code></p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li>node.js 运行环境</li><li>反编译的脚本，<a href="https://github.com/qwerty472123/wxappUnpacker" target="_blank" rel="noopener">下载地址</a></li><li>需要反编译小程序的文件 <code>xxx.wxapkg</code></li></ul><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li><p>安装反编译脚本的依赖，执行 <code>npm install</code> ，或全局安装所有依赖</p><pre><code class="node">npm install esprima -gnpm install css-tree -gnpm install cssbeautify -gnpm install vm2 -gnpm install uglify-es -gnpm install js-beautify -gnpm install escodegen -g</code></pre></li><li><p>在当前目录下输入 <code>node wuWxapkg.js [-d] //files</code> 就是你想要反编译的文件名。例： <code>node .wuWxapkg.js C:\_APP_.wxapkg</code></p></li></ol><h3 id="反编译报错解决方法"><a href="#反编译报错解决方法" class="headerlink" title="反编译报错解决方法"></a>反编译报错解决方法</h3><ul><li><p><code>ReferenceError: __mainPageFrameReady__ is not defined</code></p><p>解决方案： 打开<code>page-frame.html</code>到最底部去掉 <code>__mainPageFrameReady__()</code></p></li><li><p><code>Error: This Package is unrecognizable, please decrypted every type of file by hand.</code></p><p> 解决方案： 重新换一个<code>.wxapkg</code>文件</p></li><li><p>部分小程序反编译，会丢失wxss文件，也就是关键的样式文件。</p><p>同时会有报错提示 <code>_vd_version_info__ is not defined</code>  该问题是微信升级导致。</p><p>解决方案： 修改反编译目录下的 <code>wuWxss.js</code> 文件,修改 <code>RunVm</code> 方法为</p><pre><code class="javascript">function runVM(name,code){    let wxAppCode={},handle={cssFile:name};    let tsandbox = {        __vd_version_info__:&quot;&quot;,        $gwx:GwxCfg.prototype[&quot;$gwx&quot;],        __mainPageFrameReady__:GwxCfg.prototype[&quot;$gwx&quot;],        __wxAppCode__:wxAppCode,        setCssToHead:cssRebuild.bind(handle)    }    let vm = new VM({sandbox:tsandbox});    vm.run(code);    for(let name in wxAppCode){        if(name.endsWith(&quot;.wxss&quot;)){            handle.cssFile = path.resolve(frameName,&quot;..&quot;,name);            wxAppCode[name]();        }    }}</code></pre></li></ul><p> <a href="https://blog.csdn.net/dhnate678/article/details/97789001" target="_blank" rel="noopener">https://blog.csdn.net/dhnate678/article/details/97789001</a> </p><p> <a href="https://blog.csdn.net/rolan1993/article/details/79695913" target="_blank" rel="noopener">https://blog.csdn.net/rolan1993/article/details/79695913</a> </p><p> <a href="https://blog.csdn.net/qq_33858250/article/details/80543815" target="_blank" rel="noopener">https://blog.csdn.net/qq_33858250/article/details/80543815</a></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高德地图渲染路线</title>
      <link href="/2020/05/12/%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%E6%B8%B2%E6%9F%93%E8%B7%AF%E7%BA%BF/"/>
      <url>/2020/05/12/%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%E6%B8%B2%E6%9F%93%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<!-- # 高德地图渲染路线 --><p>在项目中，使用百度地图时，发现通过城市名获取经纬度不准确，故替换为高德地图。</p><p><img src="http://qab0509yb.bkt.clouddn.com/Snipaste_2020-05-15_10-35-15.png" alt=""></p><p>代码如下：</p><pre><code class="javascript">var points = []var adds = [&#39;江苏省无锡市惠山区&#39;,&#39;江苏省常州市金坛市&#39;,&#39;江苏省泰州市姜堰县&#39;]var startIcon = new AMap.Icon({    // 图标尺寸    size: new AMap.Size(22, 28),    image:&#39;http://new.tzwlpzw.com/homeStatic/images/dt_start.png&#39;,    // 图标所用图片大小    imageSize: new AMap.Size(22, 28),})var throughIcon = new AMap.Icon({    // 图标尺寸    size: new AMap.Size(22, 28),    image:&#39;http://new.tzwlpzw.com/homeStatic/images/dt_through.png&#39;,    // 图标所用图片大小    imageSize: new AMap.Size(22, 28),})var endIcon = new AMap.Icon({    // 图标尺寸    size: new AMap.Size(22, 28),    image:&#39;http://new.tzwlpzw.com/homeStatic/images/dt_end.png&#39;,    // 图标所用图片大小    imageSize: new AMap.Size(22, 28),})//在轨迹点上创建图标function addMarker(points){  // 创建图标对象         for(var i = 0,pointsLen = points.length;i &lt;pointsLen;i++){          if ( i &lt; 1 ) {            var marker = new AMap.Marker({                position: new AMap.LngLat(points[i].location.lng,points[i].location.lat),                icon: startIcon,                offset: new AMap.Pixel(-11, -28)            });            marker.setMap(map);            marker.setLabel({                offset: new AMap.Pixel(-10, -5),  //设置文本标注偏移量                content: &quot;&lt;div class=&#39;info&#39;&gt;&quot;+points[i].formattedAddress+&quot;&lt;/div&gt;&quot;, //设置文本标注内容                direction: &#39;right&#39; //设置文本标注方位            });        } else if ( i === points.length - 1 ) {            var marker = new AMap.Marker({                position: new AMap.LngLat(points[i].location.lng,points[i].location.lat),                icon: endIcon,                offset: new AMap.Pixel(-11, -28)            });            marker.setMap(map);            marker.setLabel({                offset: new AMap.Pixel(-10, -5),  //设置文本标注偏移量                content: &quot;&lt;div class=&#39;info&#39;&gt;&quot;+points[i].formattedAddress+&quot;&lt;/div&gt;&quot;, //设置文本标注内容                direction: &#39;right&#39; //设置文本标注方位            });        } else {            var marker = new AMap.Marker({                position: new AMap.LngLat(points[i].location.lng,points[i].location.lat),                icon: throughIcon,                offset: new AMap.Pixel(-11, -28)            });            marker.setMap(map);            marker.setLabel({                offset: new AMap.Pixel(-10, -5),  //设置文本标注偏移量                content: &quot;&lt;div class=&#39;info&#39;&gt;&quot;+points[i].formattedAddress+&quot;&lt;/div&gt;&quot;, //设置文本标注内容                direction: &#39;right&#39; //设置文本标注方位            });        }    }  }  // 批量地址解析function AGEO() {    if (index &lt; adds.length) {        var add = adds[index];        geoCode(add);        index++;    } else {        console.log(points)        addMarker(points); // 绘制图标        createPolyline (points); // 绘制折线        var newCenter = map.setFitView();    }}function geoCode(add) {    if(index &lt; adds.length){        setTimeout(window.bdGEO,400);    }    geocoder.getLocation(add, function(status, result) {        if (status === &#39;complete&#39;&amp;&amp;result.geocodes.length) {            points.push(result.geocodes[0])        }else{            log.error(&#39;根据地址查询位置失败&#39;);        }    });}function createPolyline(points) {    var polylinePath = []    for (var i = 0,pointsLen = points.length;i &lt;pointsLen;i++) {          polylinePath[i] = new AMap.LngLat(points[i].location.lng,points[i].location.lat);       }    console.log(polylinePath )    // 创建线覆盖物    var polyline = new AMap.Polyline({        path: polylinePath    });    map.add([polyline]);}var map = new AMap.Map(&quot;container&quot;, {    resizeEnable: true});var geocoder = new AMap.Geocoder({    city: &quot;全国&quot;, });var index = 0;AGEO()</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>is not defined</title>
      <link href="/2020/01/15/is%20not%20defined/"/>
      <url>/2020/01/15/is%20not%20defined/</url>
      
        <content type="html"><![CDATA[<h1 id="JS中-“is-not-defined”-如何判断defined，defined和undefined-的区别"><a href="#JS中-“is-not-defined”-如何判断defined，defined和undefined-的区别" class="headerlink" title="JS中 “is not defined” 如何判断defined，defined和undefined 的区别"></a>JS中 “is not defined” 如何判断defined，defined和undefined 的区别</h1><p>JS中 “is not defined” 我今天找了一些资料和自己试验了各种方法，都不能得到正解，故写了这个问题的解决方案。</p><h1 id="首先什么是is-not-defined？"><a href="#首先什么是is-not-defined？" class="headerlink" title="首先什么是is not defined？"></a>首先什么是is not defined？</h1><p>从字面意思上来讲就是未定义，也就是未申明。就是这个变量（对象）压根就没有。如下：</p><pre><code>console.log(sojson);//sojson is not defined</code></pre><p>可能还一知半解，我们继续往下看。</p><h1 id="is-not-defined-和-undefined-区别。"><a href="#is-not-defined-和-undefined-区别。" class="headerlink" title="is not defined 和 undefined 区别。"></a>is not defined 和 undefined 区别。</h1><p>我们大多数人都知道<a href="https://www.sojson.com/tag_undefined.html" target="_blank" rel="noopener"> undefined </a>，却不知道<a href="https://www.sojson.com/tag_defined.html" target="_blank" rel="noopener"> defined </a>，<a href="https://www.sojson.com/tag_undefined.html" target="_blank" rel="noopener"> undefined </a>是未定义，如下：</p><pre><code class="javascript">var so;console.log(so);//undefinedconsole.log(so.a);//so.a is undefined</code></pre><p>这个时候输出的是<a href="https://www.sojson.com/tag_undefined.html" target="_blank" rel="noopener"> undefined </a>。访问变量的属性就会提示<code>is undefined</code> 就是这个变量<code>so</code> 未定义值（类型）；</p><p>而<code>defined</code> 呢，如下：</p><pre><code class="javascript">console.log(so);//so is not defined</code></pre><p>其实如果理解一下其实就是未申明。也就是可以理解变量的过程是，先声明后赋值，在赋值的过程中确定了这个变量的类型。</p><p><img src="http://qab0509yb.bkt.clouddn.com/202001151.png" alt="img"></p><p>所以总结一下：is not defined 优先于 undefined ，也就是先判断这个对象是否申明了，如果没申明直接就 is not defined，如果已经申明，那么再看有没有赋值（类型），如果没有那么就是 undefined 或者 访问对象的属性就是 is undefined 。</p><h1 id="is-not-defined-如何避免"><a href="#is-not-defined-如何避免" class="headerlink" title="is not defined 如何避免"></a>is not defined 如何避免</h1><p>比如我们常用的<a href="https://www.sojson.com/tag_jquery.html" target="_blank" rel="noopener"> jquery </a>，如果出现了<code>jQuery is not defined</code> ，或者<code>$ is not defined</code> ，那么我们按以下步骤来排查：</p><ul><li>是否引入了<a href="https://www.sojson.com/tag_jquery.html" target="_blank" rel="noopener"> jQuery </a>（注意是否404）。</li><li><code>jQuery</code> 是否在依赖<a href="https://www.sojson.com/tag_jquery.html" target="_blank" rel="noopener"> jQuery </a>的<a href="https://www.sojson.com/tag_js.html" target="_blank" rel="noopener"> js </a>之前引用（因为js加载是自上而下加载）。</li><li>是否过多引入<code>jQuery</code> ，或者引入多个版本的<code>jQuery</code> 。</li></ul><p>我们自己定义对象的时候，对外要提供方法，如下：</p><pre><code class="javascript">//申明局部变量 so。var so = {     a : function(){};}//对外提供访问。window.so = so;</code></pre><h1 id="如何判断-undefined。"><a href="#如何判断-undefined。" class="headerlink" title="如何判断 undefined。"></a>如何判断 undefined。</h1><p>undefined 很好判断，如下：</p><pre><code class="javascript">var sojson;console.log(sojson == undefined);//trueconsole.log(sojson === undefined);//true;console.log(typeof sojson == &#39;undefined&#39;);//trueconsole.log(typeof sojson ===  &#39;undefined&#39;);//trueconsole.log(!sojson);//true//... ...</code></pre><h1 id="如何判断is-not-defined"><a href="#如何判断is-not-defined" class="headerlink" title="如何判断is not defined"></a>如何判断is not defined</h1><p>我在网上没找到合适的资料来判断“is not defined”，我项目中因为是公共js需要解决，对象是否定义。都不好判断。所以我用比较low的方式来判断的，如果你有好的点子，请留言或者告知我，我加上。</p><pre><code class="javascript">try{        var x = sojson.demo;    }catch(e){        console.log(e.message);//sojson is undefined}</code></pre><p>因为抛出了<code>Exception</code> ，所以能<code>catch</code> ，进入了<code>catch</code> 模块。如果有多个，请分开<code>cache</code> ，如下：</p><pre><code class="javascript">try{        var x = sojson.demo;    }catch(e){        console.log(e.message);//sojson is undefined}try{        var y = sojson.y;    }catch(e){        console.log(e.message);//sojson is undefined}</code></pre><p>因为出现一个<a href="https://www.sojson.com/tag_exception.html" target="_blank" rel="noopener"> Exception </a>，就不会往下执行了，所以要分开去处理。</p><p>[参考]：</p><p><a href="https://www.sojson.com/blog/182.html" target="_blank" rel="noopener">JS中 “is not defined” 如何判断defined，defined和undefined 的区别</a></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序的背景音乐问题</title>
      <link href="/2020/01/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%83%8C%E6%99%AF%E9%9F%B3%E4%B9%90/"/>
      <url>/2020/01/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%83%8C%E6%99%AF%E9%9F%B3%E4%B9%90/</url>
      
        <content type="html"><![CDATA[<!-- # 微信小程序的背景音乐问题 --><p>微信小程序在 IOS 下，当歌曲名称为中文时，无法播放歌曲，在安卓下正常。可以使用 <code>encodeURIComponent()</code> 将歌曲名称作为  URI 组件进行编码。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取当前websocket的连接状态</title>
      <link href="/2019/12/31/%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8Dwebsocket%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81/"/>
      <url>/2019/12/31/%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8Dwebsocket%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<!-- # 获取当前websocket的连接状态 --><p> 这是非常简单的：<code>readyState</code>websocket 的属性总是包含websocket的连接，正如<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket#Ready_state_constants" target="_blank" rel="noopener">WebSocket API</a> </p><p> 它将是以下值之一：<code>CONNECTING</code> <code>OPEN</code> <code>CLOSING</code>或<code>CLOSED</code> </p><pre><code>if(yourWsObject.readyState === yourWsObject.CLOSED){   // Do your stuff...}</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取当天的时间戳</title>
      <link href="/2019/12/23/%E8%8E%B7%E5%8F%96%E5%BD%93%E5%A4%A9%E7%9A%84%E6%97%B6%E9%97%B4%E6%88%B3/"/>
      <url>/2019/12/23/%E8%8E%B7%E5%8F%96%E5%BD%93%E5%A4%A9%E7%9A%84%E6%97%B6%E9%97%B4%E6%88%B3/</url>
      
        <content type="html"><![CDATA[<!-- # 获取当天的时间戳 --><pre><code>var start = new Date(    new Date(new Date().toLocaleDateString()).getTime()); // 当天0点var end = new Date( // 当天23:59    new Date(new Date().toLocaleDateString()).getTime() + 24 * 60 * 60 * 1000 - 1);var startTime = new Date(new Date().getTime() - 1 * 60 * 60 * 1000); // 当前时间的前一小时var endTime = new Date(new Date().getTime()); // 当前时间</code></pre><pre><code class="javascript">//获取格林时间var date1 = new Date(new Date(new Date().toLocaleDateString()).getTime());var date2 = new Date(new Date(new Date().toLocaleDateString()).getTime()+24*60*60*1000-1);//格式化时间  2018-06-06 00:00:00//如果只是简单的格式化只变成2018-6-6 0:0:0，需要运用三目运算判断并在适当的地方加上0，完成所需要的格式。var startTime = date1.getFullYear() + &quot;-&quot; + ((date1.getMonth() + 1) &lt; 10 ? &quot;0&quot; + (date1.getMonth() + 1):(date1.getMonth() + 1))+ &quot;-&quot; + (date1.getDate() &lt; 10 ? &quot;0&quot; + date1.getDate():date1.getDate()) + &quot; &quot; + (date1.getHours()&lt;10?&quot;0&quot;+date1.getHours():date1.getHours()) + &quot;:&quot; + (date1.getMinutes()&lt;10?&quot;0&quot;+date1.getMinutes():date1.getMinutes()) + &quot;:&quot; + (date1.getSeconds()&lt;10?&quot;0&quot;+date1.getSeconds():date1.getSeconds()),//格式化时间  2018-06-06 23:59:59 var endTime = date2.getFullYear() + &#39;-&#39; + (date2.getMonth() + 1) + &#39;-&#39; + date2.getDate() + &#39; &#39; + date2.getHours() + &#39;:&#39; + date2.getMinutes() + &#39;:&#39; + date2.getSeconds()</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断对象是否为空对象的几种方法</title>
      <link href="/2019/12/23/%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E4%B8%BA%E7%A9%BA%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/12/23/%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E4%B8%BA%E7%A9%BA%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<!-- # javaScript判断对象是否为空对象的几种方法 --><p>1.将 <code>json</code>对象转化为 <code>json</code> 字符串，再判断该字符串是否为 <code>&quot;{}&quot;</code></p><pre><code class="javascript">var data = {};var b = (JSON.stringify(data) == &quot;{}&quot;);alert(b);//true</code></pre><p>2.<code>for in</code> 循环判断</p><pre><code class="javascript">var obj = {};var b = function() {for(var key in obj) {    return false;}return true;}alert(b());//true</code></pre><p>3.<code>jquery</code> 的<code>isEmptyObject</code>方法<br>此方法是 <code>jquery</code> 将 2 方法 (for in) 进行封装，使用时需要依赖 <code>jquery</code></p><pre><code class="javascript">var data = {};var b = $.isEmptyObject(data);alert(b);//true</code></pre><ol start="4"><li><code>Object.getOwnPropertyNames()</code> 方法<br>此方法是使用Object对象的 <code>getOwnPropertyNames</code> 方法，获取到对象中的属性名，存到一个数组中，返回数组对象，我们可以通过判断数组的 length 来判断此对象是否为空<br>注意：此方法不兼容 IE8，其余浏览器没有测试</li></ol><pre><code class="javascript">var data = {};var arr = Object.getOwnPropertyNames(data);alert(arr.length == 0);//true</code></pre><p>5.使用 ES6 的 <code>Object.keys()</code> 方法<br>与4方法类似，是 ES6 的新方法, 返回值也是对象中属性名组成的数组</p><pre><code class="javascript">var data = {};var arr = Object.keys(data);alert(arr.length == 0);//true</code></pre><p>【参考】</p><p><a href="https://www.cnblogs.com/yxkNotes/p/11685717.html" target="_blank" rel="noopener">js判断对象是否为空对象的几种方法</a></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>window.open</title>
      <link href="/2019/12/19/windowOpen/"/>
      <url>/2019/12/19/windowOpen/</url>
      
        <content type="html"><![CDATA[<h2 id="Javascript-window-open使用POST传递值"><a href="#Javascript-window-open使用POST传递值" class="headerlink" title="Javascript window.open使用POST传递值"></a>Javascript window.open使用POST传递值</h2><pre><code class="javascript">function openWindowWithPost(url, data) {    var form = document.createElement(&quot;form&quot;);    form.target = &quot;_blank&quot;;    form.method = &quot;POST&quot;;    form.action = url;    form.style.display = &quot;none&quot;;    for (var key in data) {        var input = document.createElement(&quot;input&quot;);        input.type = &quot;hidden&quot;;        input.name = key;        input.value = data[key];        form.appendChild(input);    }    document.body.appendChild(form);    form.submit();    document.body.removeChild(form);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封装cookie方法</title>
      <link href="/2019/12/18/%E5%B0%81%E8%A3%85cookie/"/>
      <url>/2019/12/18/%E5%B0%81%E8%A3%85cookie/</url>
      
        <content type="html"><![CDATA[<!-- ## 封装cookie方法 --><pre><code class="javascript">function setCookie(cname,cvalue,exdays){    var d = new Date();    d.setTime(d.getTime()+(exdays*24*60*60*1000));    var expires = &quot;expires=&quot;+d.toGMTString();    document.cookie = cname+&quot;=&quot;+cvalue+&quot;; &quot;+expires;}function getCookie(cname){    var name = cname + &quot;=&quot;;    var ca = document.cookie.split(&#39;;&#39;);    for(var i=0; i&lt;ca.length; i++) {        var c = ca[i].trim();        if (c.indexOf(name)==0) { return c.substring(name.length,c.length); }    }    return &quot;&quot;;}function checkCookie(){    var user=getCookie(&quot;username&quot;);    if (user!=&quot;&quot;){        alert(&quot;欢迎 &quot; + user + &quot; 再次访问&quot;);    }    else {        user = prompt(&quot;请输入你的名字:&quot;,&quot;&quot;);        if (user!=&quot;&quot; &amp;&amp; user!=null){            setCookie(&quot;username&quot;,user,30);        }    }}function delCookie(name){    document.cookie = name+&quot;=;expires=&quot;+(new Date(0)).toGMTString();}</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> cookie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>添加书签至浏览器</title>
      <link href="/2019/12/14/%E6%B7%BB%E5%8A%A0%E4%B9%A6%E7%AD%BE%E8%87%B3%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
      <url>/2019/12/14/%E6%B7%BB%E5%8A%A0%E4%B9%A6%E7%AD%BE%E8%87%B3%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<!-- # 添加书签至浏览器 --><pre><code class="javascript"> // 添加书签至浏览器function addfavorite() {     var ctrl = (navigator.userAgent.toLowerCase()).indexOf(&#39;mac&#39;) != -1 ? &#39;Command/Cmd&#39;: &#39;CTRL&#39;;    try{        if (document.all) { //IE类浏览器            try {                window.external.toString(); //360浏览器不支持window.external，无法收藏                window.alert(&quot;国内开发的360浏览器等不支持主动加入收藏。\n您可以尝试通过浏览器菜单栏 或快捷键 ctrl+D 试试。&quot;);            }            catch (e){                try{                    window.external.addFavorite(window.location, document.title);                }                catch (e){                    window.external.addToFavoritesBar(window.location, document.title);  //IE8                }            }        }        else if (window.sidebar) { //firfox等浏览器            window.sidebar.addPanel(document.title, window.location, &quot;&quot;);        }        else {            alert(&#39;您可以尝试通过快捷键&#39; + ctrl + &#39; + D 加入到收藏夹~&#39;);        }    }    catch (e){        window.alert(&quot;因为IE浏览器存在bug，添加收藏失败！\n解决办法：在注册表中查找\n HKEY_CLASSES_ROOT\\TypeLib\\{EAB22AC0-30C1-11CF-A7EB-0000C05BAE0B}\\1.1\\0\\win32 \n将 C:\\WINDOWS\\system32\\shdocvw.dll 改为 C:\\WINDOWS\\system32\\ieframe.dll &quot;);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度地图搜索并上传位置</title>
      <link href="/2019/12/14/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E6%90%9C%E7%B4%A2%E5%B9%B6%E4%B8%8A%E4%BC%A0%E4%BD%8D%E7%BD%AE/"/>
      <url>/2019/12/14/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E6%90%9C%E7%B4%A2%E5%B9%B6%E4%B8%8A%E4%BC%A0%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<!-- # 百度地图搜索并上传位置 --><pre><code class="javascript">var start_point = {lng: 116.404,lat: 39.915}var map = new BMap.Map(&quot;container&quot;);map.enableScrollWheelZoom(true);     // 开启鼠标滚轮缩放// 根据经纬度自适应zoom和中点map.centerAndZoom(new BMap.Point(start_point.lng, start_point.lat), 11);  var geoc = new BMap.Geocoder() // 根据经纬度获取地址setTimeout(function() {    $(&#39;#geo&#39;).val(JSON.stringify(start_point))    // addMarker(start_point, &#39;&#39;)}, 100)// 添加定位控件var geolocationControl = new BMap.GeolocationControl({    anchor: BMAP_ANCHOR_BOTTOM_RIGHT,});geolocationControl.addEventListener(&quot;locationSuccess&quot;, function(e){    // 定位成功事件    map.clearOverlays();      var addComp = e.addressComponent;    console.log(addComp)    var pp = e.point;    var address = addComp.province + addComp.city + addComp.district + addComp.street + addComp.streetNumber;    $(&#39;#suggestId&#39;).val(address)    map.centerAndZoom(pp, 14);    $(&#39;#geo&#39;).val(JSON.stringify(pp))    addMarker(pp, address);});geolocationControl.addEventListener(&quot;locationError&quot;,function(e){    // 定位失败事件    console.log(e.message);});map.addControl(geolocationControl);// 定义一个控件类,即functionfunction ZoomControl() {    this.defaultAnchor = BMAP_ANCHOR_TOP_LEFT;    this.defaultOffset = new BMap.Size(10, 10);}// 通过JavaScript的prototype属性继承于BMap.ControlZoomControl.prototype = new BMap.Control();// 自定义控件必须实现自己的initialize方法,并且将控件的DOM元素返回// 在本方法中创建个div元素作为控件的容器,并将其添加到地图容器中ZoomControl.prototype.initialize = function(map){    // 创建一个DOM元素    var div = document.createElement(&quot;div&quot;);    // div.innerHTML = &#39;&lt;div id=&quot;r-result&quot; style=&quot;background:#fff;&quot;&gt;搜索地址:&lt;input type=&quot;text&quot; id=&quot;suggestId&quot; size=&quot;20&quot; value=&quot;无锡市&quot; style=&quot;width:150px;background:#fff;font-size:12px;color:#333;&quot; /&gt;&lt;/div&gt;&lt;div id=&quot;searchResultPanel&quot; style=&quot;border:1px solid #C0C0C0;width:150px;height:auto; display:none;&quot;&gt;&lt;/div&gt;&#39;;    div.innerHTML = `&lt;div id=&quot;r-result&quot; &gt;&lt;span&gt;搜索：&lt;/span&gt;&lt;input type=&quot;text&quot; id=&quot;suggestId&quot; size=&quot;20&quot; value=&quot;无锡市&quot; /&gt;&lt;input type=&quot;hidden&quot; id=&quot;geo&quot; value=&quot;&quot; /&gt;&lt;input type=&quot;button&quot; id=&quot;updateAddress&quot; value=&quot;上传位置&quot; /&gt;&lt;/div&gt;&lt;div id=&quot;searchResultPanel&quot;&gt;&lt;/div&gt;`    // 添加DOM元素到地图中    map.getContainer().appendChild(div);    // 将DOM元素返回    return div;}// 创建控件var myZoomCtrl = new ZoomControl();// 添加到地图当中map.addControl(myZoomCtrl);var ac = new BMap.Autocomplete(    //建立一个自动完成的对象    {&quot;input&quot; : &quot;suggestId&quot;     ,&quot;location&quot; : map    });ac.addEventListener(&quot;onhighlight&quot;, function(e) {  //鼠标放在下拉列表上的事件    var str = &quot;&quot;;    var _value = e.fromitem.value;    var value = &quot;&quot;;    if (e.fromitem.index &gt; -1) {        value = _value.province +  _value.city +  _value.district +  _value.street +  _value.business;    }    str = &quot;FromItem&lt;br /&gt;index = &quot; + e.fromitem.index + &quot;&lt;br /&gt;value = &quot; + value;    value = &quot;&quot;;    if (e.toitem.index &gt; -1) {        _value = e.toitem.value;        value = _value.province +  _value.city +  _value.district +  _value.street +  _value.business;    }    str += &quot;&lt;br /&gt;ToItem&lt;br /&gt;index = &quot; + e.toitem.index + &quot;&lt;br /&gt;value = &quot; + value;    $(&quot;#searchResultPanel&quot;).html(str);});var myValue;ac.addEventListener(&quot;onconfirm&quot;, function(e) {    //鼠标点击下拉列表后的事件    var _value = e.item.value;    myValue = _value.province +  _value.city +  _value.district +  _value.street +  _value.business;    $(&quot;#searchResultPanel&quot;).html(&quot;onconfirm&lt;br /&gt;index = &quot; + e.item.index + &quot;&lt;br /&gt;myValue = &quot; + myValue);    setPlace();});function setPlace(){    map.clearOverlays();    //清除地图上所有覆盖物    function myFun(){        var pp = local.getResults().getPoi(0).point;    //获取第一个智能搜索的结果        map.centerAndZoom(pp, 14);        $(&#39;#geo&#39;).val(JSON.stringify(pp))        addMarker(pp, &#39;&#39;)    }    var local = new BMap.LocalSearch(map, { //智能搜索        onSearchComplete: myFun    });    local.search(myValue);}function addMarker(pt, address) {    var marker = new BMap.Marker(pt)    map.addOverlay(marker);     marker.enableDragging();    var label = new BMap.Label(address,{offset:new BMap.Size(20,0)});    label.setStyle({        color : &quot;#666&quot;,        fontSize : &quot;12px&quot;,        height : &quot;24px&quot;,        lineHeight : &quot;24px&quot;,        fontFamily:&quot;微软雅黑&quot;,        padding: &#39;0 5px 0 5px&#39;,        background: &#39;#fff&#39;,        border:&#39;0&#39;,        borderRadius: &#39;3px&#39;,    });    marker.setLabel(label);    geoc.getLocation(pt, function(rs){        console.log(rs)        var addComp = rs.addressComponents;        newaddress = addComp.province + addComp.city + addComp.district + addComp.street + addComp.streetNumber;        label.setContent(newaddress)    });    // 标注拖动事件     marker.addEventListener(&quot;dragend&quot;, function(e){         var pt = e.point;        $(&#39;#geo&#39;).val(JSON.stringify(pt))        var newaddress;        geoc.getLocation(pt, function(rs){            var addComp = rs.addressComponents;            newaddress = addComp.province + addComp.city + addComp.district + addComp.street + addComp.streetNumber;            label.setContent(newaddress)        });    }); }// 上传位置$(&#39;#updateAddress&#39;).click(function(){    var geostr = $(&#39;#geo&#39;).val()    console.log( geostr )})</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度地图渲染路线</title>
      <link href="/2019/12/14/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E6%B8%B2%E6%9F%93%E8%B7%AF%E7%BA%BF/"/>
      <url>/2019/12/14/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E6%B8%B2%E6%9F%93%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<!-- # 百度地图渲染路线 --><h3 id="通过经纬度渲染路线"><a href="#通过经纬度渲染路线" class="headerlink" title="通过经纬度渲染路线"></a>通过经纬度渲染路线</h3><pre><code class="javascript">var points = [    {&quot;lng&quot;: 120.28429, &quot;lat&quot;:31.52853, &quot;title&quot;:&quot;无锡市&quot;},    {&quot;lng&quot;: 119.59794, &quot;lat&quot;:31.72322, &quot;title&quot;:&quot;常州市&quot;},    {&quot;lng&quot;: 119.43396, &quot;lat&quot;:32.13188, &quot;title&quot;:&quot;镇江市&quot;},    {&quot;lng&quot;: 119.88116, &quot;lat&quot;:32.31841, &quot;title&quot;:&quot;泰州市&quot;},]//在轨迹点上创建图标function addMarker(points){  // 创建图标对象    // 创建标注对象并添加到地图    for(var i = 0,pointsLen = points.length;i &lt;pointsLen;i++){        var point = new BMap.Point(points[i].lng,points[i].lat);        var opts = {            position : point,    // 指定文本标注所在的地理位置            offset   : new BMap.Size(0, -32)    //设置文本偏移量        }        var label = new BMap.Label(points[i].title, opts);  // 创建文本标注对象        label.setStyle({            color : &quot;#666&quot;,            fontSize : &quot;12px&quot;,            height : &quot;24px&quot;,            lineHeight : &quot;24px&quot;,            fontFamily:&quot;微软雅黑&quot;,            padding: &#39;0 5px 0 15px&#39;,            background: &#39;#fff&#39;,            border:&#39;0&#39;,            borderRadius: &#39;3px&#39;,        });        map.addOverlay(label);        // 由于生成的图标路径不对，暂时使用label代替marker创建图标        var iconOpts = {            position : point,    // 指定文本标注所在的地理位置            offset   : new BMap.Size(-12, -32)    //设置文本偏移量        }        var labelIcon = new BMap.Label(&#39;&#39;, iconOpts);  // 创建图标        if ( i &lt; 1 ) {            labelIcon.setStyle({                width : &#39;23px&#39;,                height : &quot;32px&quot;,                lineHeight : &quot;24px&quot;,                background: &#39;url(&quot;/homeStatic/images/map_icons.png&quot;) no-repeat -64px 0&#39;,                border:&#39;0&#39;,            });        } else if ( i === points.length - 1 ) {            labelIcon.setStyle({                width : &#39;23px&#39;,                height : &quot;32px&quot;,                lineHeight : &quot;24px&quot;,                background: &#39;url(&quot;/homeStatic/images/map_icons.png&quot;) no-repeat 0 0&#39;,                border:&#39;0&#39;,            });        } else {            labelIcon.setStyle({                width : &#39;23px&#39;,                height : &quot;32px&quot;,                lineHeight : &quot;24px&quot;,                background: &#39;url(&quot;/homeStatic/images/map_icons.png&quot;) no-repeat -32px 0&#39;,                border:&#39;0&#39;,            });        }        map.addOverlay(labelIcon);    }}// 创建折线function createPolyline (points) {    var allPonit = []    for (var i = 0,pointsLen = points.length;i &lt;pointsLen;i++) {        allPonit[i] = new BMap.Point(points[i].lng,points[i].lat);    }    var polyline = new BMap.Polyline( allPonit, {strokeColor:&quot;#ff6600&quot;, strokeWeight:6, strokeOpacity:1});  //定义折线    map.addOverlay(polyline);     //添加折线到地图上}var map = new BMap.Map(&quot;container&quot;);map.enableScrollWheelZoom(true);     //开启鼠标滚轮缩放// 根据经纬度自适应zoom和中点var view = map.getViewport(eval(points));var mapZoom = view.zoom;var centerPoint = view.center;map.centerAndZoom(centerPoint,mapZoom);addMarker(points); // 绘制图标createPolyline (points); // 绘制折线</code></pre><h3 id="通过城市名来渲染路线"><a href="#通过城市名来渲染路线" class="headerlink" title="通过城市名来渲染路线"></a>通过城市名来渲染路线</h3><pre><code class="javascript">var points = []var adds = [&#39;江苏省无锡市惠山区&#39;,&#39;江苏省常州市金坛市&#39;,&#39;江苏省泰州市姜堰县&#39;]//在轨迹点上创建图标function addMarker(points){  // 创建图标对象         // 创建标注对象并添加到地图         for(var i = 0,pointsLen = points.length;i &lt;pointsLen;i++){          var point = new BMap.Point(points[i].lng,points[i].lat);              var opts = {            position : point,    // 指定文本标注所在的地理位置            offset   : new BMap.Size(0, -32)    //设置文本偏移量        }        var label = new BMap.Label(points[i].title, opts);  // 创建文本标注对象        label.setStyle({            color : &quot;#666&quot;,            fontSize : &quot;12px&quot;,            height : &quot;24px&quot;,            lineHeight : &quot;24px&quot;,            fontFamily:&quot;微软雅黑&quot;,            padding: &#39;0 5px 0 15px&#39;,            background: &#39;#fff&#39;,            border:&#39;0&#39;,            borderRadius: &#39;3px&#39;,        });        map.addOverlay(label);          // 由于生成的图标路径不对，暂时使用label代替marker创建图标        var iconOpts = {            position : point,    // 指定文本标注所在的地理位置            offset   : new BMap.Size(-12, -32)    //设置文本偏移量        }        var labelIcon = new BMap.Label(&#39;&#39;, iconOpts);  // 创建图标        if ( i &lt; 1 ) {            labelIcon.setStyle({                width : &#39;23px&#39;,                height : &quot;32px&quot;,                lineHeight : &quot;24px&quot;,                background: &#39;url(&quot;./images/map_icons.png&quot;) no-repeat -64px 0&#39;,                border:&#39;0&#39;,            });        } else if ( i === points.length - 1 ) {            labelIcon.setStyle({                width : &#39;23px&#39;,                height : &quot;32px&quot;,                lineHeight : &quot;24px&quot;,                background: &#39;url(&quot;./images/map_icons.png&quot;) no-repeat 0 0&#39;,                border:&#39;0&#39;,            });        } else {            labelIcon.setStyle({                width : &#39;23px&#39;,                height : &quot;32px&quot;,                lineHeight : &quot;24px&quot;,                background: &#39;url(&quot;./images/map_icons.png&quot;) no-repeat -32px 0&#39;,                border:&#39;0&#39;,            });        }        map.addOverlay(labelIcon);      }  }  // 创建折线function createPolyline (points) {    var allPonit = []    for (var i = 0,pointsLen = points.length;i &lt;pointsLen;i++) {          allPonit[i] = new BMap.Point(points[i].lng,points[i].lat);       }    var polyline = new BMap.Polyline( allPonit, {strokeColor:&quot;#ff6600&quot;, strokeWeight:6, strokeOpacity:1});  //定义折线    map.addOverlay(polyline);     //添加折线到地图上}// 批量地址解析function bdGEO(){    if (index &lt; adds.length) {        var add = adds[index];        geocodeSearch(add);        index++;    } else {        console.log(points)        setZoom(points);        addMarker(points); // 绘制图标        createPolyline (points); // 绘制折线    }}function geocodeSearch(add){    if(index &lt; adds.length){        setTimeout(window.bdGEO,400);    }     myGeo.getPoint(add, function(point){        if (point) {            point.title = add;            points.push(point)        }    });}function getZoom (maxLng, minLng, maxLat, minLat) {      var zoom = [&quot;50&quot;,&quot;100&quot;,&quot;200&quot;,&quot;500&quot;,&quot;1000&quot;,&quot;2000&quot;,&quot;5000&quot;,&quot;10000&quot;,&quot;20000&quot;,&quot;25000&quot;,&quot;50000&quot;,&quot;100000&quot;,&quot;200000&quot;,&quot;500000&quot;,&quot;1000000&quot;,&quot;2000000&quot;]//级别18到3。      var pointA = new BMap.Point(maxLng,maxLat);  // 创建点坐标A      var pointB = new BMap.Point(minLng,minLat);  // 创建点坐标B      var distance = map.getDistance(pointA,pointB).toFixed(1);  //获取两点距离,保留小数点后两位     for (var i = 0,zoomLen = zoom.length; i &lt; zoomLen; i++) {          if(zoom[i] - distance &gt; 0){              return 18-i+3;            //之所以会多3，是因为地图范围常常是比例尺距离的10倍以上。所以级别会增加3。          }      };  }  function setZoom(points){      if(points.length&gt;0){          var maxLng = points[0].lng;          var minLng = points[0].lng;          var maxLat = points[0].lat;          var minLat = points[0].lat;          var res;          for (var i = points.length - 1; i &gt;= 0; i--) {              res = points[i];              if(res.lng &gt; maxLng) maxLng =res.lng;              if(res.lng &lt; minLng) minLng =res.lng;              if(res.lat &gt; maxLat) maxLat =res.lat;              if(res.lat &lt; minLat) minLat =res.lat;          };          var cenLng =(parseFloat(maxLng)+parseFloat(minLng))/2;          var cenLat = (parseFloat(maxLat)+parseFloat(minLat))/2;          var zoom = getZoom(maxLng, minLng, maxLat, minLat);          map.centerAndZoom(new BMap.Point(cenLng,cenLat), zoom);        }else{          //没有坐标，显示全中国          map.centerAndZoom(new BMap.Point(103.388611,35.563611), 5);        }   }  var map = new BMap.Map(&quot;container&quot;);map.centerAndZoom(new BMap.Point(117.269945,31.86713), 13);map.enableScrollWheelZoom(true);var index = 0;var myGeo = new BMap.Geocoder();bdGEO()</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度地图常用API</title>
      <link href="/2019/11/30/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E5%B8%B8%E7%94%A8API/"/>
      <url>/2019/11/30/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E5%B8%B8%E7%94%A8API/</url>
      
        <content type="html"><![CDATA[<!-- # 百度地图常用API --><pre><code class="html">&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;&lt;script&gt;    var map = new BMap.Map(&quot;container&quot;); //初始化百度地图时，注意ID必须为container    map.enableScrollWheelZoom(true);     //开启鼠标滚轮缩放&lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度地图添加折线</title>
      <link href="/2019/11/30/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E6%B7%BB%E5%8A%A0%E6%8A%98%E7%BA%BF/"/>
      <url>/2019/11/30/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E6%B7%BB%E5%8A%A0%E6%8A%98%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<!-- # 百度地图添加折线 --><pre><code class="javascript">var map = new BMap.Map(&quot;container&quot;);var point_start = new BMap.Point(120.28429,31.52853);  // 创建起点坐标var pointA = new BMap.Point(119.59794,31.72322);  // 创建点坐标Avar point_end = new BMap.Point(119.88116,32.31841);  // 创建终点坐标var polyline = new BMap.Polyline([point_start,pointA,point_end], {strokeColor:&quot;#ff6600&quot;, strokeWeight:6, strokeOpacity:1});  //定义折线map.addOverlay(polyline);     //添加折线到地图上</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度地图封装</title>
      <link href="/2019/11/30/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E5%B0%81%E8%A3%85/"/>
      <url>/2019/11/30/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<!-- # 百度地图封装 --><pre><code class="javascript">//创建和初始化地图函数：function initMap() {    createMap();//创建地图    setMapEvent();//设置地图事件    addMapControl();//向地图添加控件    addMarker();//向地图中添加marker}//创建地图函数：function createMap() {    var map = new BMap.Map(&quot;dituContent&quot;);//在百度地图容器中创建一个地图    var point = new BMap.Point(113.739165, 23.016775);//定义一个中心点坐标    map.centerAndZoom(point, 17);//设定地图的中心点和坐标并将地图显示在地图容器中    window.map = map;//将map变量存储在全局}//地图事件设置函数：function setMapEvent() {    map.enableDragging();//启用地图拖拽事件，默认启用(可不写)    map.enableScrollWheelZoom();//启用地图滚轮放大缩小    map.enableDoubleClickZoom();//启用鼠标双击放大，默认启用(可不写)    map.enableKeyboard();//启用键盘上下左右键移动地图}//地图控件添加函数：function addMapControl() {    //向地图中添加缩放控件    var ctrl_nav = new BMap.NavigationControl({anchor: BMAP_ANCHOR_TOP_LEFT, type: BMAP_NAVIGATION_CONTROL_LARGE});    map.addControl(ctrl_nav);    //向地图中添加缩略图控件    var ctrl_ove = new BMap.OverviewMapControl({anchor: BMAP_ANCHOR_BOTTOM_RIGHT, isOpen: 1});    map.addControl(ctrl_ove);    //向地图中添加比例尺控件    var ctrl_sca = new BMap.ScaleControl({anchor: BMAP_ANCHOR_BOTTOM_LEFT});    map.addControl(ctrl_sca);}//标注点数组var markerArr = [{    title: &quot;蓝居鸟科技有限公司&quot;,    content: &quot;我的备注&quot;,    point: &quot;113.739318|23.016758&quot;,    isOpen: 1,    icon: {w: 23, h: 25, l: 46, t: 21, x: 9, lb: 12}}                ];//创建markerfunction addMarker() {    for (var i = 0; i &lt; markerArr.length; i++) {        var json = markerArr[i];        var p0 = json.point.split(&quot;|&quot;)[0];        var p1 = json.point.split(&quot;|&quot;)[1];        var point = new BMap.Point(p0, p1);        var iconImg = createIcon(json.icon);        var marker = new BMap.Marker(point, {icon: iconImg});        var iw = createInfoWindow(i);        var label = new BMap.Label(json.title, {&quot;offset&quot;: new BMap.Size(json.icon.lb - json.icon.x + 10, -20)});        marker.setLabel(label);        map.addOverlay(marker);        label.setStyle({            borderColor: &quot;#808080&quot;,            color: &quot;#333&quot;,            cursor: &quot;pointer&quot;        });        (function () {            var index = i;            var _iw = createInfoWindow(i);            var _marker = marker;            _marker.addEventListener(&quot;click&quot;, function () {                this.openInfoWindow(_iw);            });            _iw.addEventListener(&quot;open&quot;, function () {                _marker.getLabel().hide();            })            _iw.addEventListener(&quot;close&quot;, function () {                _marker.getLabel().show();            })            label.addEventListener(&quot;click&quot;, function () {                _marker.openInfoWindow(_iw);            })            if (!!json.isOpen) {                label.hide();                _marker.openInfoWindow(_iw);            }        })()    }}//创建InfoWindowfunction createInfoWindow(i) {    var json = markerArr[i];    var iw = new BMap.InfoWindow(&quot;&lt;b class=&#39;iw_poi_title&#39; title=&#39;&quot; + json.title + &quot;&#39;&gt;&quot; + json.title + &quot;&lt;/b&gt;&lt;div class=&#39;iw_poi_content&#39;&gt;&quot; + json.content + &quot;&lt;/div&gt;&quot;);    return iw;}//创建一个Iconfunction createIcon(json) {    var icon = new BMap.Icon(&quot;http://api.map.baidu.com/lbsapi/creatmap/images/us_mk_icon.png&quot;, new BMap.Size(json.w, json.h), {        imageOffset: new BMap.Size(-json.l, -json.t),        infoWindowOffset: new BMap.Size(json.lb + 5, 1),        offset: new BMap.Size(json.x, json.h)    })    return icon;}</code></pre><p>链接：</p><p><a href="https://blog.csdn.net/u014132947/article/details/80277622" target="_blank" rel="noopener"><strong>解决百度地图生成器添加标注后图标不显示的问题</strong> </a></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度地图自适应显示地图</title>
      <link href="/2019/11/30/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E8%87%AA%E9%80%82%E5%BA%94%E6%98%BE%E7%A4%BA/"/>
      <url>/2019/11/30/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E8%87%AA%E9%80%82%E5%BA%94%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<!-- # 百度地图自适应显示地图**  --><h3 id="根据标注点坐标范围计算显示缩放级别zoom"><a href="#根据标注点坐标范围计算显示缩放级别zoom" class="headerlink" title="根据标注点坐标范围计算显示缩放级别zoom"></a>根据标注点坐标范围计算显示缩放级别zoom</h3><p>1、 计算缩放级别的函数</p><pre><code class="javascript">//根据经纬极值计算绽放级别。  function getZoom (maxLng, minLng, maxLat, minLat) {      var zoom = [&quot;50&quot;,&quot;100&quot;,&quot;200&quot;,&quot;500&quot;,&quot;1000&quot;,&quot;2000&quot;,&quot;5000&quot;,&quot;10000&quot;,&quot;20000&quot;,&quot;25000&quot;,&quot;50000&quot;,&quot;100000&quot;,&quot;200000&quot;,&quot;500000&quot;,&quot;1000000&quot;,&quot;2000000&quot;]//级别18到3。      var pointA = new BMap.Point(maxLng,maxLat);  // 创建点坐标A      var pointB = new BMap.Point(minLng,minLat);  // 创建点坐标B      var distance = map.getDistance(pointA,pointB).toFixed(1);  //获取两点距离,保留小数点后两位     for (var i = 0,zoomLen = zoom.length; i &lt; zoomLen; i++) {          if(zoom[i] - distance &gt; 0){              return 18-i+3;            //之所以会多3，是因为地图范围常常是比例尺距离的10倍以上。所以级别会增加3。          }      };  }  </code></pre><p>2、 计算最大经纬度，最小经纬度。计算中心点。并调用getZoom()获取显示级别 </p><pre><code class="javascript">//根据原始数据计算中心坐标和缩放级别，并为地图设置中心坐标和缩放级别。  function setZoom(points){      if(points.length&gt;0){          var maxLng = points[0].lng;          var minLng = points[0].lng;          var maxLat = points[0].lat;          var minLat = points[0].lat;          var res;          for (var i = points.length - 1; i &gt;= 0; i--) {              res = points[i];              if(res.lng &gt; maxLng) maxLng =res.lng;              if(res.lng &lt; minLng) minLng =res.lng;              if(res.lat &gt; maxLat) maxLat =res.lat;              if(res.lat &lt; minLat) minLat =res.lat;          };          var cenLng =(parseFloat(maxLng)+parseFloat(minLng))/2;          var cenLat = (parseFloat(maxLat)+parseFloat(minLat))/2;          var zoom = getZoom(maxLng, minLng, maxLat, minLat);          map.centerAndZoom(new BMap.Point(cenLng,cenLat), zoom);        }else{          //没有坐标，显示全中国          map.centerAndZoom(new BMap.Point(103.388611,35.563611), 5);        }   }  </code></pre><p>使用方法：</p><pre><code class="javascript">var points = [    {&quot;lng&quot;: 120.28429, &quot;lat&quot;:31.52853},    {&quot;lng&quot;: 119.59794, &quot;lat&quot;:31.72322},    {&quot;lng&quot;: 119.88116, &quot;lat&quot;:32.31841},];var map = new BMap.Map(&quot;container&quot;);setZoom(points);</code></pre><h3 id="通过官方API"><a href="#通过官方API" class="headerlink" title="通过官方API"></a>通过官方API</h3><pre><code class="javascript">var points = [    {&quot;lng&quot;: 120.28429, &quot;lat&quot;:31.52853},    {&quot;lng&quot;: 119.59794, &quot;lat&quot;:31.72322},    {&quot;lng&quot;: 119.88116, &quot;lat&quot;:32.31841},];var view = map.getViewport(eval(points));  var mapZoom = view.zoom;   var centerPoint = view.center;   map.centerAndZoom(centerPoint,mapZoom); </code></pre><p>链接：</p><p><a href="https://blog.csdn.net/qs17126/article/details/78083416?utm_source=blogxgwz9" target="_blank" rel="noopener">自适应显示地图</a></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度地图创建图标</title>
      <link href="/2019/11/30/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E5%88%9B%E5%BB%BA%E5%9B%BE%E6%A0%87/"/>
      <url>/2019/11/30/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E5%88%9B%E5%BB%BA%E5%9B%BE%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<!-- # 百度地图创建图标 --><pre><code class="javascript">//在轨迹点上创建图标，并添加点击事件  function addMarker(points){  // 创建图标对象         // 创建标注对象并添加到地图         for(var i = 0,pointsLen = points.length;i &lt;pointsLen;i++){          var point = new BMap.Point(points[i].lng,points[i].lat);              var  marker = new BMap.Marker(point);             map.addOverlay(marker);           //给标注点添加点击事件。使用立即执行函数和闭包          (function() {              var thePoint = points[i];              marker.addEventListener(&quot;click&quot;,function(){                  showInfo(this,thePoint);              });          })();      }  }  //显示信息窗口，显示标注点的信息。function showInfo(thisMaker,point){    var sContent =        &#39;&lt;ul style=&quot;margin:0 0 5px 0;padding:0.2em 0&quot;&gt;&#39;        +&#39;&lt;li style=&quot;line-height: 26px;font-size: 15px;&quot;&gt;&#39;        +&#39;&lt;span style=&quot;width: 50px;display: inline-block;&quot;&gt;id：&lt;/span&gt;&#39; + point.id + &#39;&lt;/li&gt;&#39;        +&#39;&lt;li style=&quot;line-height: 26px;font-size: 15px;&quot;&gt;&#39;        +&#39;&lt;span style=&quot;width: 50px;display: inline-block;&quot;&gt;名称：&lt;/span&gt;&#39; + point.name + &#39;&lt;/li&gt;&#39;        +&#39;&lt;li style=&quot;line-height: 26px;font-size: 15px;&quot;&gt;&lt;span style=&quot;width: 50px;display: inline-block;&quot;&gt;查看：&lt;/span&gt;&lt;a href=&quot;&#39;+point.url+&#39;&quot;&gt;详情&lt;/a&gt;&lt;/li&gt;&#39;        +&#39;&lt;/ul&gt;&#39;;    var infoWindow = new BMap.InfoWindow(sContent);  // 创建信息窗口对象    thisMaker.openInfoWindow(infoWindow);   //图片加载完毕重绘infowindow}</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Axios的二次封装</title>
      <link href="/2019/11/07/Axios%E7%9A%84%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85/"/>
      <url>/2019/11/07/Axios%E7%9A%84%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<!-- # Axios的二次封装 --><blockquote><p>在项目下新建一个service文件夹（与package.json同级），子文件：http.js 对axios请求头、拦截器等， reset.js：请求方法的封装，get，post等。<br> axios的二次封装跟api的封装、或者在vuex的store中使用，<br> axios的reset用于api封装用,提供api封装中使用，以及store中使用。</p></blockquote><p> 1.http.js，axios请求头、拦截器等, </p><pre><code class="javascript">import axios from &#39;axios&#39;import { Message, MessageBox } from &#39;element-ui&#39;import store from &#39;../store&#39;// 创建axios实例const service = axios.create({  // baseURL: process.env.BASE_API, // api 的 base_url  timeout: 5000 // 请求超时时间})// request拦截器service.interceptors.request.use(  config =&gt; {    if (store.getters.token) {      config.headers[&#39;X-Token&#39;] = getToken() // 让每个请求携带自定义token 请根据实际情况自行修改    }    return config  },  error =&gt; {    // Do something with request error    console.log(error) // for debug    Promise.reject(error)  })// response 拦截器service.interceptors.response.use(  response =&gt; {    /**     * code为非20000是抛错 可结合自己业务进行修改     */    const res = response.data    const codeReg = /^20\d+/    if (!codeReg.test(response.status)) {      Message({        message: res.message,        type: &#39;error&#39;,        duration: 5 * 1000      })      // 50008:非法的token; 50012:其他客户端登录了;  50014:Token 过期了;      if (res.code === 50008 || res.code === 50012 || res.code === 50014) {        MessageBox.confirm(          &#39;你已被登出，可以取消继续留在该页面，或者重新登录&#39;,          &#39;确定登出&#39;,          {            confirmButtonText: &#39;重新登录&#39;,            cancelButtonText: &#39;取消&#39;,            type: &#39;warning&#39;          }        ).then(() =&gt; {          store.dispatch(&#39;FedLogOut&#39;).then(() =&gt; {            location.reload() // 为了重新实例化vue-router对象 避免bug          })        })      }      return Promise.reject(&#39;error&#39;)    } else {      return response.data    }  },  error =&gt; {    console.log(&#39;err&#39; + error) // for debug    Message({      message: error.message,      type: &#39;error&#39;,      duration: 5 * 1000    })    return Promise.reject(error)  })export default service</code></pre><p> 2、reset.js，请求方法的封装，get，post等 </p><pre><code class="javascript">import http from &#39;./http.js&#39;export default {  post(url, data, config) {    return http.post(url, data, config)  },  get(url, params, config) {    const getConfig = {}    if (params) {      Object.assign(getConfig, {        params      })    }    if (config) Object.assign(getConfig, config)    return http.get(url, getConfig)  },  put(url, data, config) {    return http.put(url, data, config)  },  delete(url, params, config) {    const delConfig = {}    if (params) {      Object.assign(delConfig, {        params      })    }    if (config) Object.assign(delConfig, config)    return http.delete(url, delConfig)  }}</code></pre><p> 3.api封装使用： </p><pre><code class="javascript">src/api/template.js: import request from &#39;@/service/http.js&#39; // axios的封装 后续添加axios二次封装//  /cosmopaas-dev为跨域规则 前面文章有提到// post方式传参用dataexport function getCommonList(query) {  return request({    url: &#39;/cosmopaas-dev/algorithm/getAlgorithmModelPage&#39;,    method: &#39;post&#39;,    data: query  })}</code></pre><p> 4.store中使用： </p><pre><code class="javascript">//在store的xxx.js中引入import api from &#39;@/service/reset.js&#39;export default {  state: {    tenants: [], // all tenants  },  getters: {    tenants: state =&gt; state.tenants, //  all tenants    clusters: state =&gt; state.clusters //  all clusters  },  mutations: {    alertTenants: (state, data) =&gt; { // all tenants      state.tenants = data    },    alertClusters: (state, data) =&gt; { // all tenants      state.clusters = data    }  },  actions: {    // get all tenants    getTenantsAPI: (context) =&gt; {      api.get(&#39;/api/dce/tenants&#39;).then( res =&gt; {        console.log(res.data)        context.commit(&#39;alertTenants&#39;, res.data)      }).catch( error =&gt; {        console.log(error)      })    }}</code></pre><p>参考：</p><p><a href="https://www.jianshu.com/p/62b5144fb32e" target="_blank" rel="noopener">axios的二次封装</a></p><p><a href="https://segmentfault.com/a/1190000016474460" target="_blank" rel="noopener">axios基于常见业务场景的二次封装</a></p><p><a href="https://segmentfault.com/a/1190000012332982" target="_blank" rel="noopener">vue项目中对axios的二次封装</a></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-cli 3.0 打包</title>
      <link href="/2019/10/29/vue-cli%203.0%20%E6%89%93%E5%8C%85%E9%A2%84%E8%A7%88/"/>
      <url>/2019/10/29/vue-cli%203.0%20%E6%89%93%E5%8C%85%E9%A2%84%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<h1 id="vue-cli-3-0-打包并本地查看"><a href="#vue-cli-3-0-打包并本地查看" class="headerlink" title="vue-cli 3.0 打包并本地查看"></a>vue-cli 3.0 打包并本地查看</h1><p>使用命令行对项目打包</p><pre><code>npm run build</code></pre><p>完成后直接打开生成的 dist 文件夹下的 index.html ，打开后出现了一个空白页面，并且控制台报错，提示文件找不到。修改 vue.config.js 中的路径。将 baseUrl 属性的值 ‘/‘ 修改为 ‘./‘</p><pre><code class="javascript">module.exports = {  // 基本路径  baseUrl: &#39;./&#39;,  // 输出文件目录  outputDir: &#39;dist&#39;,  // webpack-dev-server 相关配置  devServer: {    port: 8888,  },}</code></pre><p>改好之后就可以打开页面了。但是登陆时需要请求 cookie ，在这里 get 返回的是空。这里需要启动一个 http 服务器来访问。</p><p>所以安装 http-server 来启动 http 服务器</p><pre><code class="javascript">npm install -g http-server//在dist文件夹下执行下面命令http-server</code></pre><p>但是打开网页时，显示 该网页无法正式工作 ，终端显示如下图</p><p><img src="http://qab0509yb.bkt.clouddn.com/201910291.png" alt=""></p><p>这样的话，我们可以安装 anywhere 来解决问题</p><pre><code class="javascript">npm install -g anywhere//在要启动静态服务的目录下执行anywhere -p 8080// -p 后跟端口号</code></pre><p>参考：</p><p> <a href="https://blog.csdn.net/weixin_40836227/article/details/99710001" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40836227/article/details/99710001</a></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE-CLI 3.0 如何创建项目</title>
      <link href="/2019/10/14/vue-cli%203.0%20%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE/"/>
      <url>/2019/10/14/vue-cli%203.0%20%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<!-- # VUE-CLI 3.0 如何创建项目 --><h3 id="安装vue-cli-3-0"><a href="#安装vue-cli-3-0" class="headerlink" title="安装vue-cli 3.0"></a>安装vue-cli 3.0</h3><p>首先查看本机是否有安装 vue-cli，在终端中运行下面命令</p><pre><code>vue --version</code></pre><p>如果安装的不是 3.0 + ，先卸载当前 vue-cli</p><pre><code>npm uninstall -g vue-clinpm install -g @vue/cli</code></pre><blockquote><p>类 unix 用户，需加上 sudo</p></blockquote><h3 id="创建初始项目"><a href="#创建初始项目" class="headerlink" title="创建初始项目"></a>创建初始项目</h3><p>在终端中，输入下面命令</p><pre><code>vue ui</code></pre><p>进入GUI中，创建项目。</p><p>或者，直接在终端中创建项目</p><pre><code>vue create project-name</code></pre><h3 id="配置项目"><a href="#配置项目" class="headerlink" title="配置项目"></a>配置项目</h3><p>在项目根目录新建一个 <code>vue.config.js</code> 文件就能使用自定义配置了</p><pre><code class="javascript">module.exports={    baseUrl: //根路径    outputDir： //输出路径    assetsDir： //静态资源    lintOnServer:false //是否开启eslint    devSer：    {      open      host      port      https        hotOnly      proxy:{        //跨域        ‘/api’:{          target:”http://api.localhost:80/api”          ws:true,          changeOrigin:true,          pathRewrite:{           ‘^/api’: ‘’          }       }     }   }}</code></pre><p>更多配置 <a href="https://cli.vuejs.org/zh/config" target="_blank" rel="noopener">看这里</a> 。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE-CLI 3.0 打包项目</title>
      <link href="/2019/10/14/vue-cli%203.0%20%E6%89%93%E5%8C%85%E9%A1%B9%E7%9B%AE/"/>
      <url>/2019/10/14/vue-cli%203.0%20%E6%89%93%E5%8C%85%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="解决vue-cli3-0打包上线静态资源找不到路径问题"><a href="#解决vue-cli3-0打包上线静态资源找不到路径问题" class="headerlink" title="解决vue cli3.0打包上线静态资源找不到路径问题"></a>解决vue cli3.0打包上线静态资源找不到路径问题</h2><p>解决方法是：<br>在项目的根目录下创建vue.config,js文件，在里面配置静态资源的路径，publicPath是配置静态资源路径的属性，vue.config,js文件的代码如下： </p><pre><code class="javascript">module.exports = {    publicPath: &#39;./&#39;}</code></pre><p>项目打包上传<br><a href="https://blog.csdn.net/jingtian678/article/details/80637948" target="_blank" rel="noopener">https://blog.csdn.net/jingtian678/article/details/80637948</a></p><p>打包后，element图标丢失<br><a href="https://www.jianshu.com/p/7d59213427a9" target="_blank" rel="noopener">https://www.jianshu.com/p/7d59213427a9</a></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue.config.js 的配置</title>
      <link href="/2019/10/14/vue.config.js%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/10/14/vue.config.js%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<pre><code class="javascript">const path = require(&#39;path&#39;)const debug = process.env.NODE_ENV !== &#39;production&#39;//const VueConf = require(&#39;./src/assets/js/libs/vue_config_class&#39;)//const vueConf = new VueConf(process.argv)module.exports = {    publicPath: &#39;/&#39;, // 根域上下文目录    outputDir: &#39;dist&#39;, // 构建输出目录    assetsDir: &#39;assets&#39;, // 静态资源目录 (js, css, img, fonts)    indexPath: &#39;index.html&#39;,    // lintOnSave: true, // 是否开启eslint保存检测，有效值：ture | false | &#39;error&#39;    // runtimeCompiler: true, // 运行时版本是否需要编译    // transpileDependencies: [], // 默认babel-loader忽略mode_modules，这里可增加例外的依赖包名    // productionSourceMap: false, // 是否在构建生产包时生成 sourceMap 文件，false将提高构建速度    // productionSourceMap: true, // 是否在构建生产包时生成 sourceMap 文件，false将提高构建速度    //     css: { // 配置高于chainWebpack中关于css loader的配置    //     modules: true, // 是否开启支持‘foo.module.css’样式    //     extract: true, // 是否使用css分离插件 ExtractTextPlugin，采用独立样式文件载入，不采用&lt;style&gt;方式内联至html文件中    //     sourceMap: false, // 是否在构建样式地图，false将提高构建速度    //     loaderOptions: { // css预设器配置项    //         sass: {    //             data: &#39;&#39;//`@import &quot;@/assets/scss/mixin.scss&quot;;`    //         }    //     }    // },    // configureWebpack: config =&gt; { // webpack配置，值位对象时会合并配置，为方法时会改写配置    //     if (debug) { // 开发环境配置    //         config.devtool = &#39;cheap-module-eval-source-map&#39;    //     } else { // 生产环境配置    //     }    //      Object.assign(config, { // 开发生产共同配置，配置别名    //          resolve: {    //              alias: {    //                  &#39;@&#39;: path.resolve(__dirname, &#39;./src&#39;),    //                  &#39;@c&#39;: path.resolve(__dirname, &#39;./src/components&#39;),    //                 &#39;vue$&#39;: &#39;vue/dist/vue.esm.js&#39;    //             }    //         }    //      })    // },    // chainWebpack: config =&gt; { // webpack链接API，用于生成和修改webapck配置，    //     if (debug) {    //         // 本地开发配置    //     } else {    //         // 生产开发配置    //     }    // },    // parallel: require(&#39;os&#39;).cpus().length &gt; 1, // 构建时开启多进程处理babel编译    // pluginOptions: { // 第三方插件配置    // },    // pwa: { // 单页插件相关配置 https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-pwa    // },    devServer: {        open: true,        host: &#39;localhost&#39;,        port: 80,        // https: false,        // hotOnly: false,        // proxy: &#39;http://127.0.0.1:8080&#39; // 配置跨域处理,只有一个代理        proxy: { // 配置跨域            &#39;/api&#39;: {　　　　　　　　　　//要访问的跨域的api的域名                target: &#39;http://127.0.0.1:2233/api&#39;,                ws: true,                changOrigin: true,                pathRewrite: {                    &#39;^/api&#39;: &#39;&#39;                }            }        },        // before: app =&gt; { }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端开发技巧</title>
      <link href="/2019/10/12/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
      <url>/2019/10/12/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<!-- # 移动端开发技巧 --><h3 id="META-相关"><a href="#META-相关" class="headerlink" title="META 相关"></a>META 相关</h3><p><strong>1.添加到主屏后的标题（IOS）</strong></p><pre><code>&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt;</code></pre><p><strong>2.启用 WebApp 全屏模式（IOS）</strong></p><pre><code>&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt; &lt;meta name=&quot;apple-touch-fullscreen&quot; content=&quot;yes&quot; /&gt; </code></pre><p><strong>3.百度禁止转码。通过百度手机打开网页时，百度可能会对你的网页进行转码，往你页面贴上它的广告，非常之恶心。不过我们可以通过这个 meta 标签来禁止它：</strong></p><pre><code>&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt;</code></pre><p><strong>4.设置状态栏的背景颜色（IOS）设置状态栏的背景颜色，只有在 <code>&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;</code>  时生效</strong></p><pre><code>  &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black-translucent&quot; /&gt;    default ：状态栏背景是白色。    black ：状态栏背景是黑色。    black-translucent ：状态栏背景是半透明。 如果设置为 default 或 black ,网页内容从状态栏底部开始。 如果设置为 black-translucent ,网页内容充满整个屏幕，顶部会被状态栏遮挡。</code></pre><p><strong>5.开启短信功能：</strong></p><pre><code>&lt;a href=&quot;sms:123456&quot;&gt;123456&lt;/a&gt;</code></pre><p><strong>6.移动端邮箱识别（Android）</strong><br>与电话号码的识别一样，在安卓上会对符合邮箱格式的字符串进行识别，我们可以通过如下的meta来管别邮箱的自动识别：</p><pre><code>&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot; /&gt; </code></pre><p>同样地，我们也可以通过标签属性来开启长按邮箱地址弹出邮件发送的功能：</p><pre><code>&lt;a mailto:dooyoe@gmail.com&quot;&gt;dooyoe@gmail.com&lt;/a&gt;</code></pre><p>viewport 模板</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;meta content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; name=&quot;viewport&quot;&gt;        &lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot;&gt; &lt;!-- 当网站添加到主屏幕快速启动方式，可隐藏地址栏，仅针对 ios 的 safari --&gt;        &lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot;&gt; &lt;!-- 将网站添加到主屏幕快速启动方式，仅针对 ios 的 safari 顶端状态条的样式 --&gt;        &lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot;&gt; &lt;!-- 禁止将页面中的数字识别为电话号码 --&gt;        &lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot;&gt; &lt;!-- 忽略 Android 平台中对邮箱地址的识别 --&gt;        &lt;title&gt;标题&lt;/title&gt;        &lt;link rel=&quot;icon&quot; href=&quot;favicon.ico&quot; mce_href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot;&gt; &lt;!-- 自定义 favicon --&gt;        &lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt;    &lt;/head&gt;    &lt;body&gt;        这里开始内容    &lt;/body&gt;&lt;/html&gt;    </code></pre><h3 id="CSS相关"><a href="#CSS相关" class="headerlink" title="CSS相关"></a>CSS相关</h3><pre><code class="css">body {    font-family: &quot;Helvetica Neue&quot;, Helvetica, STHeiTi, sans-serif; /*使用无衬线字体*/}a, img {    -webkit-touch-callout: none; /*禁止长按链接与图片弹出菜单*/}html, body {    -webkit-user-select: none; /*禁止选中文本*/    user-select: none;}button,input,optgroup,select,textarea {    -webkit-appearance:none; /*去掉webkit默认的表单样式*/}a,button,input,optgroup,select,textarea {    -webkit-tap-highlight-color:rgba(0,0,0,0); /*去掉a、input和button点击时的蓝色外边框和灰色半透明背景*/}input::-webkit-input-placeholder {    color:#ccc; /*修改webkit中input的planceholder样式*/}input:focus::-webkit-input-placeholder {    color:#f00; /*修改webkit中focus状态下input的planceholder样式*/}body {    -webkit-text-size-adjust: 100%!important; /*禁止IOS调整字体大小*/}input::-webkit-input-speech-button {    display: none; /*隐藏Android的语音输入按钮*/}</code></pre><h3 id="三大手机系统的字体"><a href="#三大手机系统的字体" class="headerlink" title="三大手机系统的字体"></a>三大手机系统的字体</h3><p><strong>1.ios 系统</strong></p><pre><code>默认中文字体是 Heiti SC默认英文字体是 Helvetica默认数字字体是 HelveticaNeue无微软雅黑字体        </code></pre><p><strong>2.android 系统</strong></p><pre><code>默认中文字体是 Droidsansfallback默认英文和数字字体是 Droid Sans无微软雅黑字体</code></pre><p><strong>3.winphone 系统</strong></p><pre><code>默认中文字体是 Dengxian (方正等线体)默认英文和数字字体是 Segoe无微软雅黑字体各个手机系统有自己的默认字体，且都不支持微软雅黑如无特殊需求，手机端无需定义中文字体，使用系统默认英文字体和数字字体可使用 Helvetica ，三种系统都支持        </code></pre><p>移动端字体单位 <code>font-size</code> 选择 px 还是 rem 对于只需要适配手机设备，使用 px 即可对于需要适配各种移动设备，使用 rem，例如只需要适配 iPhone 和 iPad 等分辨率差别比较挺大的设备 rem 配置参考：</p><pre><code class="css">html {font-size:10px}@media screen and (min-width:480px) and (max-width:639px) {    html {        font-size: 15px    }}@media screen and (min-width:640px) and (max-width:719px) {    html {        font-size: 20px    }}@media screen and (min-width:720px) and (max-width:749px) {    html {        font-size: 22.5px    }}@media screen and (min-width:750px) and (max-width:799px) {    html {        font-size: 23.5px    }}@media screen and (min-width:800px) and (max-width:959px) {    html {        font-size: 25px    }}@media screen and (min-width:960px) and (max-width:1079px) {    html {        font-size: 30px    }}@media screen and (min-width:1080px) {    html {        font-size: 32px    }}    </code></pre><h3 id="移动端-touch-事件（区分-webkit-和-winphone-）"><a href="#移动端-touch-事件（区分-webkit-和-winphone-）" class="headerlink" title="移动端 touch 事件（区分 webkit 和 winphone ）"></a>移动端 touch 事件（区分 webkit 和 winphone ）</h3><p><strong>当用户手指放在移动设备在屏幕上滑动会触发的 touch 事件</strong></p><ul><li><p>以下支持 webkit<br><code>touchstart</code>—— 当手指触碰屏幕时候发生。不管当前有多少只手指<br><code>touchmove</code>—— 当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用 event 的  <code>preventDefault()</code>  可以阻止默认情况的发生：阻止页面滚动<br><code>touchend</code>—— 当手指离开屏幕时触发<br><code>touchcancel</code>—— 系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用</p></li><li><p>以下支持 winphone 8<br><code>MSPointerDown</code>——当手指触碰屏幕时候发生。不管当前有多少只手指<br><code>MSPointerMove</code>——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用 css 的 <code>html{-ms-touch-action: none;}</code> 可以阻止默认情况的发生：阻止页面滚动<br><code>MSPointerUp</code>——当手指离开屏幕时触发</p></li></ul><p><strong>移动端 click 屏幕产生 200-300 ms 的延迟响应移动设备上的 web 网页是有 300ms 延迟的，玩玩会造成按钮点击延迟甚至是点击失效。</strong> </p><p>解决延迟方案：</p><ul><li><p><a href="https://github.com/ftlabs/fastclick" target="_blank" rel="noopener">fastclick</a>  可以解决在手机上点击事件的 300ms 延迟</p></li><li><p><a href="https://github.com/madrobby/zepto" target="_blank" rel="noopener">zepto</a>  的 <code>touch</code> 模块，<code>tap</code> 事件也是为了解决在 <code>click</code> 的延迟问题</p></li><li><p>触摸事件的响应顺序</p><pre><code>ontouchstart --&gt; ontouchmove --&gt; ontouchend --&gt; onclick</code></pre><p>解决300ms延迟的问题，也可以通过绑定 <code>ontouchstart</code> 事件，加快对事件的响应。</p></li></ul><p><strong>ios 系统中元素被触摸时产生的半透明灰色遮罩怎么去掉 ios 用户点击一个链接，会出现一个半透明灰色遮罩, 如果想要禁用，可设置 -webkit-tap-highlight-color 的 alpha 值为 0，也就是属性值的最后一位设置为 0 就可以去除半透灰色遮罩</strong> </p><pre><code class="css">a, button, input, textarea {    -webkit-tap-highlight-color: rgba(0,0,0,0)}</code></pre><p><strong>部分 android 系统中元素被点击时产生的边框怎么去掉 android 用户点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样，可设置 -webkit-tap-highlight-color 的 alpha 值为 0 去除部分机器自带效果</strong> </p><pre><code class="css">a, button, input, textarea {    -webkit-tap-highlight-color: rgba(0,0,0,0)    -webkit-user-modify:read-write-plaintext-only; } </code></pre><p> <strong>禁止文本缩放</strong><br>当移动设备横竖屏切换时，文本的大小会重新计算，进行相应的缩放，当我们不需要这种情况时，可以选择禁止： </p><pre><code class="css">html {    -webkit-text-size-adjust: 100%;}</code></pre><h3 id="屏幕旋转的事件和样式"><a href="#屏幕旋转的事件和样式" class="headerlink" title="屏幕旋转的事件和样式"></a>屏幕旋转的事件和样式</h3><p><strong>事件：</strong><br><code>window.orientation</code>，取值：正负 90 表示横屏模式、0 和 180 表现为竖屏模式； </p><pre><code class="javascript">window.onorientationchange = function() {    switch(window.orientation){        case -90:        case 90:            alert(&quot;横屏:&quot; + window.orientation);        case 0:        case 180:            alert(&quot;竖屏:&quot; + window.orientation);            break;    }}</code></pre><p> <strong>样式：</strong></p><pre><code class="css">//竖屏时使用的样式@media all and (orientation:portrait) {    .css{}}//横屏时使用的样式@media all and (orientation:landscape) {    .css{}}</code></pre><h3 id="屏幕旋转为横屏时，字体大小会变"><a href="#屏幕旋转为横屏时，字体大小会变" class="headerlink" title="屏幕旋转为横屏时，字体大小会变"></a>屏幕旋转为横屏时，字体大小会变</h3><p>具体出现的情况不明😒，有时候有有时候没有，欢迎指出。</p><p>优化代码：</p><pre><code class="css">* {  -webkit-text-size-adjust: 100%;}</code></pre><h3 id="手机拍照和上传图片"><a href="#手机拍照和上传图片" class="headerlink" title="手机拍照和上传图片"></a>手机拍照和上传图片</h3><pre><code class="html">&lt;input type=&quot;file&quot;&gt; 的accept 属性&lt;!-- 选择照片 --&gt;&lt;input type=file accept=&quot;image/*&quot;&gt;&lt;!-- 选择视频 --&gt;&lt;input type=file accept=&quot;video/*&quot;&gt;&lt;!-- 多选 --&gt;&lt;input type=&quot;file&quot; multiple&gt;</code></pre><p><strong>消除transition闪屏</strong> </p><pre><code class="css">.css{    /*设置内嵌的元素在 3D 空间如何呈现：保留 3D*/    -webkit-transform-style: preserve-3d;    /*（设置进行转换的元素的背面在面对用户时是否可见：隐藏）*/    -webkit-backface-visibility: hidden;}</code></pre><p>开启硬件加速<br>解决页面闪白<br>保证动画流畅 </p><pre><code class="css">.css {    -webkit-transform: translate3d(0, 0, 0);    -moz-transform: translate3d(0, 0, 0);    -ms-transform: translate3d(0, 0, 0);    transform: translate3d(0, 0, 0);}    </code></pre><h3 id="弹出数字键盘"><a href="#弹出数字键盘" class="headerlink" title="弹出数字键盘"></a>弹出数字键盘</h3><pre><code class="html">&lt;!-- 有&quot;#&quot; &quot;*&quot;符号输入 --&gt;&lt;input type=&quot;tel&quot;&gt;&lt;!-- 纯数字 --&gt;&lt;input pattern=&quot;\d*&quot;&gt;</code></pre><p> <code>android</code> 跟 <code>IOS</code>的表现形式应该不一样，大家可以自己试试。当运用了正则 <code>pattern</code> 后，就不用关注 <code>input</code> 的类型了。</p><h3 id="取消input在ios下，输入的时候英文首字母的默认大写"><a href="#取消input在ios下，输入的时候英文首字母的默认大写" class="headerlink" title="取消input在ios下，输入的时候英文首字母的默认大写"></a>取消input在ios下，输入的时候英文首字母的默认大写</h3><pre><code class="html">&lt;input autocapitalize=&quot;off&quot; autocorrect=&quot;off&quot; /&gt;</code></pre><h3 id="解决input失焦后页面没有回弹"><a href="#解决input失焦后页面没有回弹" class="headerlink" title="解决input失焦后页面没有回弹"></a>解决input失焦后页面没有回弹</h3><p>一般出现在<code>IOS设备中的微信内部浏览器</code>，出现的条件为：</p><ul><li>页面高度过小</li><li>聚焦时，页面需要往上移动的时候</li></ul><p>所以一般 <code>input</code> 在页面上方或者顶部都不会出现无法回弹🤣</p><p>解决办法为，在聚焦时，获取当前滚动条高度，然后失焦时，赋值之前获取的高度：</p><pre><code class="html">&lt;template&gt;  &lt;input type=&quot;text&quot; @focus=&quot;focus&quot; @blur=&quot;blur&quot;&gt;&lt;/template&gt;&lt;script&gt;  export default {    data() {      return {        scrollTop: 0      }    },    methods: {      focus() {        this.scrollTop = document.scrollingElement.scrollTop;      },      blur() {        document.scrollingElement.scrollTo(0, this.scrollTop);      }    }  }&lt;/script&gt;</code></pre><h3 id="浏览器点击行为"><a href="#浏览器点击行为" class="headerlink" title="浏览器点击行为"></a>浏览器点击行为</h3><pre><code class="html">&lt;!-- 拨号 --&gt;&lt;a href=&quot;tel:10086&quot;&gt;打电话给: 10086&lt;/a&gt;&lt;!-- 发送短信 --&gt;&lt;a href=&quot;sms:10086&quot;&gt;发短信给: 10086&lt;/a&gt;&lt;!-- 发送邮件 --&gt;&lt;a href=&quot;mailto:839626987@qq.com&quot;&gt;发邮件给：839626987@qq.com&lt;/a&gt;</code></pre><h3 id="打开原生应用"><a href="#打开原生应用" class="headerlink" title="打开原生应用"></a>打开原生应用</h3><pre><code class="html">&lt;a href=&quot;weixin://&quot;&gt;打开微信&lt;/a&gt;&lt;a href=&quot;alipays://&quot;&gt;打开支付宝&lt;/a&gt;&lt;a href=&quot;alipays://platformapi/startapp?saId=10000007&quot;&gt;打开支付宝的扫一扫功能&lt;/a&gt;&lt;a href=&quot;alipays://platformapi/startapp?appId=60000002&quot;&gt;打开支付宝的蚂蚁森林&lt;/a&gt;</code></pre><p> 这种方式叫做 <code>URL Scheme</code>，是一种协议，一般用来访问<code>APP</code>或者<code>APP</code>中的某个功能/页面（如唤醒 <code>APP</code> 后打开指定页面或者使用某些功能） </p><p> <code>URL Scheme</code> 的基本格式如下： </p><pre><code>     行为(应用的某个功能/页面)                |scheme://[path][?query]   |               |应用标识       功能需要的参数</code></pre><p>一般是由<code>APP</code>开发者自己定义，比如规定一些<code>参数</code>或者<code>路径</code>让其他开发者来访问</p><p><strong>注意事项：</strong></p><ul><li>唤醒<code>APP</code>的条件是你的手机已经安装了该<code>APP</code></li><li>某些浏览器会禁用此协议，比如微信内部浏览器（除非开了白名单）</li></ul><h3 id="解决-active-伪类失效"><a href="#解决-active-伪类失效" class="headerlink" title="解决 active 伪类失效"></a>解决 active 伪类失效</h3><pre><code class="html">&lt;body ontouchstart&gt;&lt;/body&gt;</code></pre><p> 给 <code>body</code> 注册一个空事件即可 </p><h3 id="禁止长按"><a href="#禁止长按" class="headerlink" title="禁止长按"></a>禁止长按</h3><p> 每个手机以及浏览器的表现形式不一样， 可以总结成这几个 ：<em>长按图片保存</em>、<em>长按选择文字</em>、<em>长按链接/手机号/邮箱时呼出菜单</em>。</p><p> 想要禁止这些浏览器的默认行为，可以使用以下 <code>CSS</code>： </p><pre><code class="css">// 禁止长按图片保存img {  -webkit-touch-callout: none;  pointer-events: none; // 像微信浏览器还是无法禁止，加上这行样式即可}// 禁止长按选择文字div {  -webkit-user-select: none;}// 禁止长按呼出菜单div {  -webkit-touch-callout: none;}</code></pre><h3 id="滑动不顺畅，粘手"><a href="#滑动不顺畅，粘手" class="headerlink" title="滑动不顺畅，粘手"></a>滑动不顺畅，粘手</h3><p> 一般出现在<code>IOS</code>设备中，自定义盒子使用了 <code>overflow: auto || scroll</code> 后出现的情况。 </p><p> 优化代码： </p><pre><code class="css">div {  -webkit-overflow-scrolling: touch;}</code></pre><h3 id="最简单的rem自适应"><a href="#最简单的rem自适应" class="headerlink" title="最简单的rem自适应"></a>最简单的rem自适应</h3><p>大家都知道，<code>rem</code>的值是根据<code>根元素的字体大小</code>相对计算的，但是我们每个设备的大小不一样，所以<strong>根元素的字体大小</strong>要动态设置</p><pre><code class="css">html { font-size: calc(100vw / 3.75);}body {  font-size: .14rem;}</code></pre><p>或者直接使用 <code>lib-flexible</code>、<code>postcss-pxtorem</code> 。</p><h3 id="自定义苹果图标"><a href="#自定义苹果图标" class="headerlink" title="自定义苹果图标"></a>自定义苹果图标</h3><p>在网站文件根目录放一个 <code>apple-touch-icon.png</code> 文件，苹果设备保存网站为书签或桌面快捷方式时，就会使用这个文件作为图标，文件尺寸建议为：180px × 180px。</p><h3 id="自定义favicon"><a href="#自定义favicon" class="headerlink" title="自定义favicon"></a>自定义favicon</h3><pre><code class="html">&lt;link rel=&quot;icon&quot; href=&quot;favicon.ico&quot; mce_href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot;&gt;</code></pre><p>参考：</p><p><a href="https://segmentfault.com/a/1190000020629722" target="_blank" rel="noopener">稍微整理了几个经常在H5移动端开发遇到的东西😢</a></p><p><a href="https://segmentfault.com/a/1190000004096304" target="_blank" rel="noopener">移动端开发技巧</a></p><p><a href="https://segmentfault.com/a/1190000003978778" target="_blank" rel="noopener">移动WEB前端开发资源整合</a></p><p><a href="https://segmentfault.com/a/1190000009326763" target="_blank" rel="noopener">移动端h5开发总结不断更新中….</a></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>元素的水平垂直居中</title>
      <link href="/2019/10/12/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"/>
      <url>/2019/10/12/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<!-- # 元素的水平垂直居中 --><h3 id="已知元素宽高"><a href="#已知元素宽高" class="headerlink" title="已知元素宽高"></a>已知元素宽高</h3><h4 id="margin负值-绝对定位"><a href="#margin负值-绝对定位" class="headerlink" title="margin负值 + 绝对定位"></a>margin负值 + 绝对定位</h4><p>优点：兼容性好。</p><p>缺点：需提前知道元素的尺寸，否则需借助JS获得。</p><pre><code class="css">.child {    width: 600px; height: 400px;    position: absolute; left: 50%; top: 50%;    margin-top: -200px;    /* 高度的一半 */    margin-left: -300px;    /* 宽度的一半 */}</code></pre><h4 id="calc-绝对定位"><a href="#calc-绝对定位" class="headerlink" title="calc + 绝对定位"></a>calc + 绝对定位</h4><p>缺点：兼容性差</p><pre><code class="css">.parent {    position: relative;    width: 300px;    height: 300px;    font-size: 0;    background: #80848f;}.child {    width: 60px;    height: 50px;    background: #19be6b;    position: absolute;    left: calc(50% - 30px);    top: calc(50% - 25px);}</code></pre><h3 id="未知元素宽高"><a href="#未知元素宽高" class="headerlink" title="未知元素宽高"></a>未知元素宽高</h3><h4 id="transform-绝对定位"><a href="#transform-绝对定位" class="headerlink" title="transform + 绝对定位"></a>transform + 绝对定位</h4><p>优点：不需知道元素尺寸</p><p>缺点：兼容性不好，只支持IE9+ </p><pre><code class="css">.child {    width: 600px; height: 400px;    position: absolute; left: 50%; top: 50%;    transform: translate(-50%, -50%);    /* 50%为自身尺寸的一半 */}</code></pre><h4 id="margin：auto-绝对定位"><a href="#margin：auto-绝对定位" class="headerlink" title="margin：auto + 绝对定位"></a><code>margin：auto</code> + 绝对定位</h4><p>优点：兼容性好，不需知道元素尺寸</p><p>缺点：不支持IE7以下的浏览器 </p><pre><code class="css">.element {    width: 600px; height: 400px;    position: absolute; left: 0; top: 0; right: 0; bottom: 0;    margin: auto;    /* 有了这个就自动居中了 */}</code></pre><h4 id="：before伪类-vertical-align-middle"><a href="#：before伪类-vertical-align-middle" class="headerlink" title="：before伪类 + vertical-align: middle"></a>：before伪类 + <code>vertical-align: middle</code></h4><p>优点：兼容性好，不需知道元素尺寸</p><p><a href="https://segmentfault.com/a/1190000020646920" target="_blank" rel="noopener">理解:before伪类搭配vertical-align:middle实现垂直居中的原理</a></p><pre><code class="css">.parent {    display: inline-block;    width: 300px;    height: 300px;    font-size: 0;    background: #80848f;    text-align: center;}.parent:before {    display: inline-block;    width: 20px;    height: 100%;    content: &#39;&#39;;    background: #ff9900;    vertical-align: middle;}.child {    display: inline-block;    width: 50px;    height: 50px;    background: #19be6b;    vertical-align: middle;}</code></pre><h4 id="line-heihgt-vertical-align-middle"><a href="#line-heihgt-vertical-align-middle" class="headerlink" title="line-heihgt  + vertical-align: middle"></a>line-heihgt  + <code>vertical-align: middle</code></h4><pre><code class="css">.parent {    width: 300px;    height: 300px;    font-size: 0;    line-height: 300px;    background: #80848f;    text-align: center;}.child {    display: inline-block;    width: 60px;    height: 50px;    background: #19be6b;    vertical-align: middle;}</code></pre><h4 id="table-cell"><a href="#table-cell" class="headerlink" title="table-cell"></a>table-cell</h4><pre><code class="css">.parent {    width: 300px;    height: 300px;    font-size: 0;    background: #80848f;    display: table-cell;    vertical-align: middle;    text-align: center;}.child {    width: 60px;    height: 50px;    background: #19be6b;    display: inline-block;    vertical-align: top;}</code></pre><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p>缺点：兼容性差</p><pre><code class="css">.parent {    width: 300px;    height: 300px;    font-size: 0;    background: #80848f;    display: -webkit-flex; /* Safari */    display: flex;    justify-content: center;    align-items: center;}.child {    width: 60px;    height: 50px;    background: #19be6b;}/* or */.parent {    width: 300px;    height: 300px;    font-size: 0;    background: #80848f;    display: -webkit-flex; /* Safari */    display: flex;}.child {    width: 60px;    height: 50px;    background: #19be6b;    margin: auto;}</code></pre><h4 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h4><pre><code class="css">/* or */.parent {    width: 300px;    height: 300px;    font-size: 0;    background: #80848f;    display: grid;}.child {    width: 60px;    height: 50px;    background: #19be6b;    margin: auto;}</code></pre><h4 id="writing-mode"><a href="#writing-mode" class="headerlink" title="writing-mode"></a>writing-mode</h4><p>优点：居中元素不需要设置宽高， 兼容ie8</p><p>缺点： 必须要有文字，有局限性</p><pre><code class="html">&lt;style&gt; .center-box{    writing-mode: tb-lr;    writing-mode: vertical-lr;    text-align: center;}.center-wrap{    writing-mode: lr-tb;    writing-mode: horizontal-tb;    text-align: center;    width: 100%;    display: inline-block;}.center-content{    display: inline-block;    text-align: left;    text-align: initial;}&lt;/style&gt;&lt;div class=&quot;center-box&quot;&gt;    &lt;div class=&quot;center-wrap&quot;&gt;        &lt;div class=&quot;center-content&quot;&gt;            你想要上下左右居中的内容(元素,文本或其任意组合)        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雅虎前端优化</title>
      <link href="/2019/10/11/%E9%9B%85%E8%99%8E%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"/>
      <url>/2019/10/11/%E9%9B%85%E8%99%8E%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<!-- # 雅虎前端优化的35条军规 --><h2 id="内容部分"><a href="#内容部分" class="headerlink" title="内容部分"></a>内容部分</h2><h3 id="1-尽量减少HTTP请求数"><a href="#1-尽量减少HTTP请求数" class="headerlink" title="1.尽量减少HTTP请求数"></a>1.尽量减少HTTP请求数</h3><p>到终端用户的响应时间80%花在前端：大部分用于下载组件（js/css/image/flash等等）。减少组件数就是减少渲染页面所需的http请求数。这是更快页面的关键。</p><p>减少组件数的一个方法就是简化页面设计。保持富内容的页面且能减少http请求，有以下几个技术：</p><ul><li>Combined files。合并文件，如合并js，合并css都能减少请求数。如果页面间脚本和样式差异很大，合并会更具挑战性。</li><li>CSS Sprites。雪碧图可以合并多个背景图片，通过<code>background-image</code> 和 <code>background-position</code> 来显示不同部分。</li><li>Image maps。合并多个图片到一个图片，一般用于如导航条。由于定义坐标的枯燥和易错，一般<em>不推荐</em>。</li><li>Inline images。使用<code>data:url scheme</code>来內连图片。</li></ul><p>减少请求数是为第一次访问页面的用户提高性能的最重要的指导。</p><h3 id="2-减少DNS查找"><a href="#2-减少DNS查找" class="headerlink" title="2.减少DNS查找"></a>2.减少DNS查找</h3><p>域名系统建立了主机名和IP地址间的映射，就像电话簿，你在浏览器地址栏输入网址，通过DNS查询得到网站真实IP。</p><p>DNS查询被缓存来提高性能。这种缓存可能发生在特定的缓存服务器（ISP/local area network维护），或者用户的计算机。DNS信息留存在操作系统DNS缓存中（在windows中就是 <em>DNS Client Serve</em> ）。大多浏览器有自己的缓存，独立于操作系统缓存。只要浏览器在自己的缓存里有某条DNS记录，它就不会向操作系统发DNS解析请求。</p><p>IE默认缓存DNS记录30分钟，FireFox默认缓存1分钟。</p><p>当客户端的DNS缓存是空的，DNS查找次数等于页面中的唯一域名数。</p><p>减少DNS请求数可能会减少并行下载数。避免DNS查找减少响应时间，但减少并行下载数可能会增加响应时间。指导原则是组件可以分散在至少2个但不多于4个的不同域名。这是两者的妥协。</p><h3 id="3-避免重定向"><a href="#3-避免重定向" class="headerlink" title="3.避免重定向"></a>3.避免重定向</h3><p>重定向用301和302状态码，下面是一个有301状态码的HTTP头：</p><pre><code>HTTP/1.1 301 Moved PermanentlyLocation: http://example.com/newuriContent-Type: text/html</code></pre><p>浏览器自动跳转到<code>Location</code>指定的路径。跳转所需的所有信息都在http头，所以http主体一般是空的。<code>301</code> <code>302</code>响应一般不会被缓存，除非有额外的头部信息，比如<code>Expires</code>或<code>Cache-Control</code>指定要缓存。<code>meta</code>刷新标签或 JavaScript 也可以跳转，但如果真要跳转，<code>3xx</code>跳转更好，主要是保证返回键可用。</p><p>跳转显然拖慢响应速度。在跳转的页面被获取前浏览器没什么能渲染，没什么组件能下载。</p><p>最浪费的跳转之一发生在url尾部slash（/）缺失。比如<code>http://astrology.yahoo.com/astrology</code>会<code>301</code>跳转到<code>http://astrology.yahoo.com/astrology/</code>。这可以被Apache等服务器修复，用<code>Alias</code>，<code>mod_rewrite</code>等等。</p><h3 id="4-让Ajax可缓存"><a href="#4-让Ajax可缓存" class="headerlink" title="4.让Ajax可缓存"></a>4.让Ajax可缓存</h3><p>使用ajax的好处是可以向用户提供很快的反馈，因为它是向后台异步请求数据。但是，这些异步请求不保证用户等待的时间——异步不意味着瞬时。</p><p>提高ajax性能的最重要的方法是让响应被缓存，即在<a href="https://link.jianshu.com/?t=https%3A%2F%2Fdeveloper.yahoo.com%2Fperformance%2Frules.html%23expires" target="_blank" rel="noopener">Add an Expires or a Cache-Control Header</a>中讨论的 Expires 。其它方法是：</p><ul><li>gzip组件</li><li>减少DNS查找</li><li>压缩JS</li><li>避免跳转</li><li>设置ETags</li></ul><h3 id="5-延迟加载组件"><a href="#5-延迟加载组件" class="headerlink" title="5.延迟加载组件"></a>5.延迟加载组件</h3><p>可以凑近看看页面并问自己：什么才是一开始渲染页面所必须的？其余内容都可以等会儿。</p><p>JavaScript是分隔onload事件之前和之后的一个理想选择。例如，如果有JavaScript代码和支持拖放以及动画的库，这些都可以先等会儿，因为拖放元素是在页面最初渲染之后的。其它可以延迟加载的部分包括隐藏内容（在某个交互动作之后才出现的内容）和折叠的图片。</p><p>工具可帮你减轻工作量：<a href="https://developer.yahoo.com/yui/imageloader/" target="_blank" rel="noopener">YUI Image Loader</a>可以延迟加载折叠的图片，还有<a href="https://developer.yahoo.com/yui/get/" target="_blank" rel="noopener">YUI Get utility</a>是一种引入JS和CSS的简单方法。<a href="http://www.yahoo.com/" target="_blank" rel="noopener">Yahoo!主页</a>就是一个例子，可以打开Firebug的网络面板仔细看看。</p><p>最好让性能目标符合其它web开发最佳实践，比如“渐进增强”。如果客户端支持JavaScript，可以提高用户体验，但必须确保页面在不支持JavaScript时也能正常工作。所以，在确定页面运行正常之后，可以用一些延迟加载脚本增强它，以支持一些拖放和动画之类的华丽效果。</p><h3 id="6-预加载组件"><a href="#6-预加载组件" class="headerlink" title="6.预加载组件"></a>6.预加载组件</h3><p>预加载看起来与延迟加载相反，但它的确有个不同的目标。通过预加载你可以利用浏览器的空闲时间来请求你将来会用到的组件。这样当用户访问下一个页面时，你会有更多的组件已经在缓存中，这样会极大加快页面加载。</p><p>有几种预加载类型：</p><ul><li>无条件预加载：一旦<code>onload</code>触发，你立即获取另外的组件。比如谷歌会在主页这样加载搜索结果页面用到的雪碧图。</li><li>有条件预加载：基于用户动作，你推测用户下一步会去哪里并加载相应组件。</li><li>提前的预加载：在发布重新设计（的网站）前提前加载。在旧网页预加载新网页的部分组件，那么切换到新网页时就不会是没有任何缓存了。</li></ul><h3 id="7-减少DOM元素的数量"><a href="#7-减少DOM元素的数量" class="headerlink" title="7.减少DOM元素的数量"></a>7.减少DOM元素的数量</h3><p>一个复杂的页面意味着更多的内容要下载，以及更慢的dom访问。比如在有500dom数量的页面添加事件处理就和有5000dom数量的不同。</p><p>如果你的页面dom元素很多，那么意味着你可能需要删除无用的内容和标签来优化。</p><h3 id="8-跨域分离组件"><a href="#8-跨域分离组件" class="headerlink" title="8.跨域分离组件"></a>8.跨域分离组件</h3><p>把组件分散到不同的域名允许你最大化并行下载数。由于DNS查询的副作用，最佳的不同域名数是2-4。</p><h3 id="9-尽量少用iframe"><a href="#9-尽量少用iframe" class="headerlink" title="9.尽量少用iframe"></a>9.尽量少用iframe</h3><p><code>iframe</code>允许 html文档被插入到父文档。</p><p>优点：</p><ul><li>帮助解决缓慢的第三方内容的加载，如广告和徽章</li><li>安全沙盒</li><li>并行下载脚本</li></ul><p>缺点：</p><ul><li>即使空的也消耗（资源和时间）</li><li>阻塞了页面的<code>onload</code></li><li>非语义化（标签）</li></ul><h3 id="10-杜绝404"><a href="#10-杜绝404" class="headerlink" title="10.杜绝404"></a>10.杜绝404</h3><p>http请求是昂贵的，所以发出http请求但获得没用的响应（如404）是完全不必要的，并且会降低用户体验。</p><p>一些网站会有特别的404页面提高用户体验，但这仍然会浪费服务器资源。特别坏的是当链接指向外部js但却得到404结果。这样首先会降低（占用）并行下载数，其次浏览器可能会把404响应体当作js来解析，试图从里面找出可用的东西。</p><h2 id="css部分"><a href="#css部分" class="headerlink" title="css部分"></a>css部分</h2><h3 id="11-避免使用CSS表达式"><a href="#11-避免使用CSS表达式" class="headerlink" title="11.避免使用CSS表达式"></a>11.避免使用CSS表达式</h3><p>CSS表达式是强大的（可能也是危险的）设置动态CSS属性的方法。IE5开始支持，IE8开始不赞成使用。例如，背景颜色可以设置成每小时轮换：</p><pre><code class="css">background-color: expression( (new Date()).getHours()%2 ? &quot;#B8D4FF&quot; : &quot;#F08A00&quot; );</code></pre><p>CSS表达式的问题是它们可能比大多数人预期的计算的更频繁。它们不仅在页面载入和调整大小时重新计算，也在滚动页面甚至是用户在页面上移动鼠标时计算。比如在页面上移动鼠标可能轻易计算超过10000次。</p><p>要避免CSS表达式计算太多次，可以在它第一次计算后替换成确切值，或者用事件处理函数而不是CSS表达式</p><h3 id="12-选择-link标签-舍弃-import"><a href="#12-选择-link标签-舍弃-import" class="headerlink" title="12.选择 link标签 舍弃 @import"></a>12.选择 link标签 舍弃 @import</h3><p>之前的一个最佳原则是说CSS应该在顶部来允许逐步渲染。</p><p>在IE用<code>@import</code>和把CSS放到页面底部行为一致，所以最好别用</p><h3 id="13-避免使用（IE）滤镜"><a href="#13-避免使用（IE）滤镜" class="headerlink" title="13.避免使用（IE）滤镜"></a>13.避免使用（IE）滤镜</h3><p>IE专有的<code>AlphaImageLoader</code>过滤器用于修复IE7以下版本的半透明真彩色PNG的问题。这个过滤器的问题是它阻止了渲染，并在图片下载时冻结了浏览器。另外它还引起内存消耗，并且它被应用到每个元素而不是每个图片，所以问题（的严重性）翻倍了。</p><p>最佳做法是放弃<code>AlphaImageLoader</code>，改用PNG8来优雅降级。</p><h3 id="14-把样式表放在顶部"><a href="#14-把样式表放在顶部" class="headerlink" title="14.把样式表放在顶部"></a>14.把样式表放在顶部</h3><p>研究雅虎网页性能时发现把样式表移到<code>&lt;head&gt;</code>里会让页面更快。这是因为把样式表移到<code>&lt;head&gt;</code>里允许页面逐步渲染。</p><p>关注性能的前端工程师希望页面被逐步渲染，这时因为，我们希望浏览器尽早渲染获取到的任何内容。这对大页面和网速慢的用户很重要。给用户视觉反馈，比如进度条的重要性已经被大量研究和记录。在我们的情况中，<code>HTML</code>页面就是进度条。当浏览器逐步加载页面头部，导航条，logo等等，这些都是给等待页面的用户的视觉反馈。这优化了整体用户体验。</p><p>把样式表放在文档底部的问题是它阻止了许多浏览器的逐步渲染，包括IE。这些浏览器阻止渲染来避免在样式更改时需要重绘页面元素。所以用户会卡在白屏。</p><p><a href="https://link.jianshu.com/?t=http%3A%2F%2Fwww.w3.org%2FTR%2Fhtml4%2Fstruct%2Flinks.html%23h-12.3" target="_blank" rel="noopener">HTML规范</a>清楚表明样式应该在<code>&lt;head&gt;</code>里。</p><h2 id="js部分"><a href="#js部分" class="headerlink" title="js部分"></a>js部分</h2><h3 id="15-去除重复脚本"><a href="#15-去除重复脚本" class="headerlink" title="15.去除重复脚本"></a>15.去除重复脚本</h3><p>在页面中引入相同的脚本两次会伤害性能。可能超出你的预料，美国top10网站的2家有重复脚本引入。两个主要因素造成同一页面引入相同脚本：团队大小和脚本数量。当确实引入重复脚本，会发出不必要的http请求和浪费js执行时间。</p><p>发出不必要的http请求发生在IE而不是Firefox。在IE，如果外部脚本引入两次且没有缓存，它会发出2个请求。即使脚本被缓存，刷新时也会发出额外请求。</p><p>除了增加http请求，时间被浪费在执行脚本多次上。不管IE还是Firefox都会执行多次。</p><p>一种避免多次引入脚本的方法是在模板系统实现一个脚本管理模块。</p><h3 id="16-尽量减少DOM访问"><a href="#16-尽量减少DOM访问" class="headerlink" title="16.尽量减少DOM访问"></a>16.尽量减少DOM访问</h3><p>用JS访问DOM元素是缓慢的，所以为了响应更好的页面，你应该：</p><ul><li>缓存访问过的元素的引用</li><li>在DOM树外更新节点，然后添加到DOM树</li><li>避免用JS实现固定布局</li></ul><h3 id="17-用智能的事件处理器"><a href="#17-用智能的事件处理器" class="headerlink" title="17.用智能的事件处理器"></a>17.用智能的事件处理器</h3><p>有时候页面看起来不那么响应（响应速度慢），是因为绑定到不同元素的大量事件处理函数执行太多次。这是为什么使用<em>事件委托</em>是一种好方法。</p><p>另外，你不必等到<code>onload</code>事件来开始处理DOM树，<code>DOMContentLoaded</code>更快。大多时候你需要的只是想访问的元素已在DOM树中，所以你不必等到所有图片被下载。</p><h3 id="18-把脚本放在底部"><a href="#18-把脚本放在底部" class="headerlink" title="18.把脚本放在底部"></a>18.把脚本放在底部</h3><p>脚本引起的问题是它们阻塞了并行下载。<a href="https://link.jianshu.com/?t=http%3A%2F%2Fwww.w3.org%2FProtocols%2Frfc2616%2Frfc2616-sec8.html%23sec8.1.4" target="_blank" rel="noopener">HTTP1.1规范</a>建议浏览器每个域名下不要一次下载超过2个组件。如果你的图片分散在不同服务器，那么你能并行下载多个图片。但<strong>当脚本在下载，浏览器不会再下载其它组件，即使在不同域名下</strong>。</p><p>有些情况下把脚本移动到底部并不简单。比如，脚本中用了<code>document.write</code>来插入内容，它就不能被移动到底部。另外有可能有作用域问题。但大多数情况，有方法可以解决这些问题。</p><p>一个替代建议是使用异步脚本。<code>defer</code>属性表明脚本不包含<code>document.write</code>，是提示浏览器继续渲染的线索。不幸的是，Firefox不支持。如果脚本能异步，那么也就可以移动到底部。</p><h2 id="javascript-css"><a href="#javascript-css" class="headerlink" title="javascript, css"></a>javascript, css</h2><h3 id="19-把JavaScript和CSS放到外面"><a href="#19-把JavaScript和CSS放到外面" class="headerlink" title="19.把JavaScript和CSS放到外面"></a>19.把JavaScript和CSS放到外面</h3><p>这里的很多性能规则涉及外部组件怎么管理。但你首先要明白一个基本问题：JS和CSS是应该包含在外部文件还是內连在页面本身？</p><p>真实世界中使用外部文件一般会加快页面，因为JS和CSS文件被浏览器缓存了。內连的JS和CSS怎在每次HTML文档下载时都被下载。內连减少了http请求，但增加了HTML文档大小。另一方面，如果JS和CSS被缓存了，那么HTML文档可以减小大小而不增加HTTP请求。</p><p>核心因素，就是JS和CSS被缓存相对于HTML文档被请求的频率。尽管这个因素很难被量化，但可以用不同的指标来计算。如果网站用户每个session有多个pv，许多页面重用相同的JS和CSS，那么有很大可能用外部JS和CSS更好。</p><p>许多网站用这些指标计算后在中间位置。对这些网站来说，最佳方案还是用外部JS和CSS文件。唯一例外是內连更被主页偏爱，如 <a href="https://link.jianshu.com/?t=http%3A%2F%2Fwww.yahoo.com%2F%E3%80%82%E4%B8%BB%E9%A1%B5%E6%AF%8F%E4%B8%AAsession%E5%8F%AF%E8%83%BD%E5%8F%AA%E6%9C%89%E5%B0%91%E9%87%8F%E7%9A%84%E7%94%9A%E8%87%B3%E4%B8%80%E4%B8%AApv%EF%BC%8C%E8%BF%99%E6%97%B6%E5%80%99%E5%85%A7%E8%BF%9E%E5%8F%AF%E8%83%BD%E6%9B%B4%E5%BF%AB%E3%80%82" target="_blank" rel="noopener">http://www.yahoo.com/ </a>。主页每个session可能只有少量的甚至一个pv，这时候內连可能更快。</p><p>对多个页面的首页来说，可以通过技术减少（其它页面的）http请求。在首页用內连，初始化后动态加载外部文件，接下来的页面如果用到这些文件，就可以使用缓存了。</p><h3 id="20-压缩JavaScript和CSS"><a href="#20-压缩JavaScript和CSS" class="headerlink" title="20.压缩JavaScript和CSS"></a>20.压缩JavaScript和CSS</h3><p>压缩就是删除代码中不必要的字符来减小文件大小，从而提高加载速度。当代码压缩时，注释删除，不需要的空格（空白，换行，tab）也被删除。</p><p>混淆是对代码可选的优化。它比压缩更复杂，并且可能产生bug。在对美国top10网站的调查，压缩可减小21%，而混淆可减小25%。</p><p>除了外部脚本和样式，內连的脚本和样式同样应该被压缩。</p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><h3 id="21-优化图片"><a href="#21-优化图片" class="headerlink" title="21.优化图片"></a>21.优化图片</h3><p>在设计师建好图片后，在上传图片到服务器前你仍可以做些事：</p><ul><li>检查gif图片的调色板大小是否匹配图片颜色数。</li><li>可以把gif转成png看看有没有变小。除了动画，gif一般可以转成png8。</li><li>运行<code>pngcrush</code>或其它工具压缩png。</li><li>运行<code>jpegtran</code>或其它工具压缩jpeg。</li></ul><h3 id="22-优化CSS-Sprite"><a href="#22-优化CSS-Sprite" class="headerlink" title="22.优化CSS Sprite"></a>22.优化CSS Sprite</h3><ul><li>把图片横向合并而不是纵向，横向更小。</li><li>把颜色近似的图片合并到一张雪碧图，这样可以让颜色数更少，如果低于256就可以用png8.</li><li>“Be mobile-friendly”并且合并时图片间的间距不要太大。这对图片大小影响不是太大，但客户端解压时需要的内存更少。100×100是10000个像素，1000×1000是1000000个像素</li></ul><h3 id="23-不要用HTML缩放图片"><a href="#23-不要用HTML缩放图片" class="headerlink" title="23.不要用HTML缩放图片"></a>23.不要用HTML缩放图片</h3><p>不要因为你可以设置图片的宽高就去用比你需要的大得多的图片。如果你需要</p><pre><code>&lt;img width=&quot;100&quot; height=&quot;100&quot; src=&quot;mycat.jpg&quot; alt=&quot;My Cat&quot; /&gt;</code></pre><p>那么，就用100x100px的图片，而不是500x500px的。</p><h3 id="24-用小的可缓存的favicon-ico"><a href="#24-用小的可缓存的favicon-ico" class="headerlink" title="24.用小的可缓存的favicon.ico"></a>24.用小的可缓存的favicon.ico</h3><p>favicon.ico是在你服务器根路径的图片。邪恶的是即使你不关心它，浏览器仍然会请求它。所以最好不要响应404。另外由于在同一服务器，每次请求favicon.ico时也会带上cookie。这个图片还会影响下载顺序，比如在IE，如果你在<code>onload</code>时下载额外的组件，fcvicon会在这些组件之前被下载。</p><p>怎么减轻favicon.ico的缺点？</p><ul><li>小，最好1K以下</li><li>设置Expires头部。也许可以安全地设置为几个月。</li></ul><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><h3 id="25-给Cookie减肥"><a href="#25-给Cookie减肥" class="headerlink" title="25.给Cookie减肥"></a>25.给Cookie减肥</h3><p>http cookie的使用有多种原因，比如授权和个性化。cookie的信息通过http头部在浏览器和服务器端交换。尽可能减小cookie的大小来降低响应时间。</p><ul><li>消除不必要的cookie。</li><li>尽可能减小cookie的大小来降低响应时间。</li><li>注意设置cookie到合适的域名级别，则其它子域名不会被影响。</li><li>正确设置Expires日期。早一点的Expires日期或者没有会尽早删除cookie，优化响应时间。</li></ul><h3 id="26-把组件放在不含cookie的域下"><a href="#26-把组件放在不含cookie的域下" class="headerlink" title="26.把组件放在不含cookie的域下"></a>26.把组件放在不含cookie的域下</h3><p>当浏览器请求静态图片并把cookie一起发送到服务器时，cookie此时对服务器没什么用处。所以这些cookie只是增加了网络流量。所以你应该保证静态组件的请求是没有cookie的。可以创建一个子域名来托管所有静态组件。</p><p>比如，你域名是<code>www.example.org</code>，可以把静态组件托管在<code>static.example.org</code>。不过，你如果把cookie设置在顶级域名<code>example.org</code>下，这些cookie仍然会被传给<code>static.example.org</code>。这种情况下，启用一个全新的域名来托管静态组件。</p><p>另外一个用没有cookie的域名提供组件的好处是，某些代理可能会阻止缓存待cookie的静态组件请求。</p><h2 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h2><h3 id="27-保证所有组件都小于25K"><a href="#27-保证所有组件都小于25K" class="headerlink" title="27.保证所有组件都小于25K"></a>27.保证所有组件都小于25K</h3><p>这个限制与iPhone不缓存大于25K的组件相关。注意，这是非压缩（uncompressed）的文件大小。在这里minification（压缩，不要与compress混淆）很重要，因为gzip无法满足（iPhone）。</p><h3 id="28-把组件打包到一个复合文档里"><a href="#28-把组件打包到一个复合文档里" class="headerlink" title="28.把组件打包到一个复合文档里"></a>28.把组件打包到一个复合文档里</h3><p>打包组件到一个多部父文档类似于带附件的邮件。它帮助你在一个http请求中获取多个组件，但注意，iPhone不支持。</p><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><h3 id="29-传输时用gzip压缩组件"><a href="#29-传输时用gzip压缩组件" class="headerlink" title="29.传输时用gzip压缩组件"></a>29.传输时用gzip压缩组件</h3><p>http请求或响应的传输时间可以被前端工程师显著减少。终端用户的带宽，ISP，接近对等交换点等等没法被开发团队控制，但是，压缩可以通过减少http响应的大小减少响应时间。</p><p>从<code>HTTP/1.1</code>开始，客户端通过http请求中的<code>Accept-Encoding</code>头部来提示支持的压缩：</p><pre><code class="undefined">Accept-Encoding: gzip, deflate</code></pre><p>如果服务器看到这个头部，它可能会选用列表中的某个方法压缩响应。服务器通过<code>Content-Encoding</code>头部提示客户端：</p><pre><code class="undefined">Content-Encoding: gzip</code></pre><p>gzip一般可减小响应的70%。尽可能去gzip更多（文本）类型的文件。html，脚本，样式，xml和json等等都应该被gzip，而图片，pdf等等不应该被gzip，因为它们本身已被压缩过，gzip它们只是浪费cpu，甚至增加文件大小。</p><h3 id="30-避免图片src属性为空"><a href="#30-避免图片src属性为空" class="headerlink" title="30.避免图片src属性为空"></a>30.避免图片src属性为空</h3><p>空src属性的图片的行为可能跟你预期的不一样。它有两种形式：</p><ol><li>html标签：<code>&lt;img src=&quot;&quot;&gt;</code></li><li>js：<code>var img = new Image(); img.src = &quot;&quot;;</code></li></ol><p>两种都会造成同一种后果：浏览器会向你的服务器发请求。</p><ul><li>IE，向页面所在的目录发请求。</li><li>Safari和Chrome，请求实际的页面。</li><li>FireFox3及之前和Safari/Chrome一样，但从3.5开始修复问题，不再发请求。</li><li>Opera遇到空图片src不做任何事。</li></ul><p><strong>为什么这种行为很糟糕？</strong></p><ol><li>由于发送大量的意料之外的流量，会削弱服务器，尤其那些每天pv上百万的页面。</li><li>浪费服务器计算周期取生成不会被浏览的页面。</li><li>可能会破坏用户数据。如果你在跟踪请求状态，通过cookie或其它，你可能会破坏数据。即使image的请求不会返回图片，但所有的头部数据都被浏览器读取了，包括cookie。即使剩下的响应体被丢弃，破坏可能已经发生。</li></ol><p>这种行为的根源是uri解析发生在浏览器。RFC 3986 定义了这种行为，空字符串被当作相对路径，Firefox, Safari, 和 Chrome都正确解析，而IE错误。总之，浏览器解析空字符串为相对路径的行为被认为是符合预期的。</p><p>html5在<em>4.8.2</em>添加了对标签src属性的描述，指导浏览器不要发出额外的请求。</p><p>The src attribute must be present, and must contain a valid URL referencing a non-interactive, optionally animated, image resource that is neither paged nor scripted. If the base URI of the element is the same as the document’s address, then the src attribute’s value must not be the empty string.</p><p>幸运的是将来浏览器不会有这个问题了（在图片上）。不幸的是，<code>&lt;script src=&quot;&quot;&gt;</code>和<code>&lt;link href=&quot;&quot;&gt;</code>没有这样的规范。</p><h3 id="31-配置ETags"><a href="#31-配置ETags" class="headerlink" title="31.配置ETags"></a>31.配置ETags</h3><p>实体标记（Entity tags，ETag）是服务器和浏览器之间判断浏览器缓存中某个组件是否匹配服务器端原组件的一种机制。实体就是组件：图片，脚本，样式等等。ETag被当作验证实体的比最后更改（<code>last-modified</code>）日期更高效的机制。服务器这样设置组件的ETag：</p><pre><code class="undefined">HTTP/1.1 200 OKLast-Modified: Tue, 12 Dec 2006 03:03:59 GMTETag: &quot;10c24bc-4ab-457e1c1f&quot;Content-Length: 12195</code></pre><p>之后，如果浏览器要验证组件，它用<code>If-None-Match</code>头部来传ETag给服务器。如果ETag匹配，服务器返回304：</p><pre><code class="undefined">GET /i/yahoo.gif HTTP/1.1Host: us.yimg.comIf-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMTIf-None-Match: &quot;10c24bc-4ab-457e1c1f&quot;HTTP/1.1 304 Not Modified</code></pre><p>ETag的问题是它们被构造来使它们对特定的运行这个网站的服务器唯一。浏览器从一个服务器获取组件，之后向另一个服务器验证，ETag将不匹配。然而服务器集群是处理请求的通用解决方案。</p><p>如果不能解决多服务器间的ETag匹配问题，那么删除ETag可能更好。</p><h3 id="32-对Ajax用GET请求"><a href="#32-对Ajax用GET请求" class="headerlink" title="32.对Ajax用GET请求"></a>32.对Ajax用GET请求</h3><p><a href="https://link.jianshu.com/?t=http%3A%2F%2Fmail.yahoo.com%2F" target="_blank" rel="noopener">Yahoo! Mail</a>团队发现当使用<code>XMLHttpRequest</code>，POST 被浏览器实现为两步：首先发送头部，然后发送数据。所以使用GET最好，仅用一个TCP包发送（除非cookie太多）。IE的url长度限制是2K。</p><p>POST但不提交任何数据根GET行为类似，但从语义上讲，获取数据应该用GET，提交数据到服务器用POST。</p><h3 id="33-尽早清空缓冲区-Flush-the-Buffer-Early"><a href="#33-尽早清空缓冲区-Flush-the-Buffer-Early" class="headerlink" title="33.尽早清空缓冲区/Flush the Buffer Early"></a>33.尽早清空缓冲区/Flush the Buffer Early</h3><p>当用户请求一个页面，服务器一般要花200-500ms来拼凑整个页面。这段时间，浏览器是空闲的（等数据返回）。在php，有个方法<code>flush()</code>允许你传输部分准备好的html响应给浏览器。这样的话浏览器就可以开始下载组件，而同时后台可以继续生成页面剩下的部分。这种好处更多是在忙碌的后台或轻前端网站可以看到。</p><p>一个比较好的flush的位置是在<code>head</code>之后，因为浏览器可以加载其中的样式和脚本文件，而后台继续生成页面剩余部分。</p><pre><code> ... &lt;!-- css, js --&gt;    &lt;/head&gt;    &lt;?php flush(); ?&gt;    &lt;body&gt;      ... &lt;!-- content --&gt;</code></pre><h3 id="34-使用CDN（内容分发网络）"><a href="#34-使用CDN（内容分发网络）" class="headerlink" title="34.使用CDN（内容分发网络）"></a>34.使用CDN（<strong>内容分发网络</strong>）</h3><p>用户接近你的服务器会减少响应时间。把你的内容发布到多个，地理上分散的服务器可以让页面加载更快。但怎么开始？</p><p>首先不要试图把你的架构重新设计成分布式架构。因为可能引进更多复杂性和不可控。</p><p>记住80-90%的终端用户响应时间花费在下载页面中的所有组件：图片、样式、脚本、falsh等等。这是<em>Performance Golden Rule</em>。不要从困难的重新设计后台架构开始，最好首先分发你的静态内容。这不仅可以减少响应时间，用CDN还很容易来做。</p><p>CDN是一群不同地点的服务器，可以更高效地分发内容到用户。一些大公司有自己的CDN。</p><h3 id="35-添上Expires或者Cache-Control-HTTP头"><a href="#35-添上Expires或者Cache-Control-HTTP头" class="headerlink" title="35.添上Expires或者Cache-Control HTTP头"></a>35.添上Expires或者Cache-Control HTTP头</h3><p>这条规则有两个方面：</p><ul><li>对静态组件：通过设置<code>Expires</code>头部来实现“永不过期”策略。</li><li>对动态组件：用合适的<code>Cache-Control</code>头部来帮助浏览器进行有条件请求。</li></ul><p>页面越来越丰富，意味着更多脚本，样式，图片等等。第一次访问的用户可能需要发出多个请求，但使用Expires可以让这些组件被缓存。这避免了访问子页面时没必要的http请求。Expires一般用在图片上，但应该用在所有的组件上。</p><p>浏览器（以及代理）使用缓存来减少http请求数，加快页面加载。服务器使用http响应的<code>Expires</code>头部来告诉客户端一个组件可以缓存多久。比如下面：</p><pre><code class="cpp">Expires: Thu, 15 Apr 2010 20:00:00 GMT //2010-04-15</code></pre><p><strong>注意</strong>，如果你设置了<code>Expires</code>头部，当组件更新后，你必须更改文件名。</p><p>参考：</p><p><a href="https://www.jianshu.com/p/4c0f9cae3ba5" target="_blank" rel="noopener">雅虎前端优化35条规则翻译</a></p><p><a href="https://www.cnblogs.com/xianyulaodi/p/5755079.html" target="_blank" rel="noopener">雅虎前端优化的35条军规</a></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js实现promise的方法</title>
      <link href="/2019/10/10/js%E5%AE%9E%E7%8E%B0promise/"/>
      <url>/2019/10/10/js%E5%AE%9E%E7%8E%B0promise/</url>
      
        <content type="html"><![CDATA[<!-- # js实现promise的方法 --><pre><code class="javascript">const PromisePolyfill = (() =&gt; {    //状态管理    const promiseStatusSymbol = Symbol(&#39;PromiseStatus&#39;);    const promiseValueSymbol = Symbol(&#39;PromiseValue&#39;);    const STATUS = {        PENDING: &#39;PENDING&#39;,        FULFILLED: &#39;FULFILLED&#39;,        REJECTED: &#39;REJECTED&#39;    };    //resolve操作设置值和状态    function resolve() {        this[promiseValueSymbol] = arguments[0];        this[promiseStatusSymbol] = STATUS[&#39;FULFILLED&#39;];    }    //reject操作设置值和状态    function reject() {        this[promiseValueSymbol] = arguments[0];        this[promiseStatusSymbol] = STATUS[&#39;REJECTED&#39;];    }    class myPromise {        constructor(resolver) {            if (typeof resolver !== &#39;function&#39;) {                throw new TypeError(`parameter 1 must be a function, but get a ${typeof func}`);            }            this[promiseStatusSymbol] = STATUS[&#39;PENDING&#39;];//初始状态为pending            resolver(                resolve.bind(this),//绑定promise实例对象                reject.bind(this)            );        }        then(callback) {            //开一个定时器监听状态变化，如果有变化则执行callback            const interval = setInterval(() =&gt; {                if (this[promiseStatusSymbol] === &#39;FULFILLED&#39; || this[promiseStatusSymbol] === &#39;REJECTED&#39;) {                    clearInterval(interval);                    callback(this[promiseValueSymbol], resolve.bind(this), reject.bind(this));                    this[promiseStatusSymbol] = &#39;PENDING&#39;;//执行完后把状态改回，方便下一个then方法进行定时轮询                }            });            return this;        }    }    return myPromise;})();</code></pre><p>面试够用版：</p><pre><code class="javascript">function myPromise(constructor){    let self=this;    self.status=&quot;pending&quot; //定义状态改变前的初始状态    self.value=undefined;//定义状态为resolved的时候的状态    self.reason=undefined;//定义状态为rejected的时候的状态    function resolve(value){        //两个===&quot;pending&quot;，保证了状态的改变是不可逆的       if(self.status===&quot;pending&quot;){          self.value=value;          self.status=&quot;resolved&quot;;       }    }    function reject(reason){        //两个===&quot;pending&quot;，保证了状态的改变是不可逆的       if(self.status===&quot;pending&quot;){          self.reason=reason;          self.status=&quot;rejected&quot;;       }    }    //捕获构造异常    try{       constructor(resolve,reject);    }catch(e){       reject(e);    }}myPromise.prototype.then=function(onFullfilled,onRejected){   let self=this;   switch(self.status){      case &quot;resolved&quot;:        onFullfilled(self.value);        break;      case &quot;rejected&quot;:        onRejected(self.reason);        break;      default:          }}// 测试代码var p=new myPromise(function(resolve,reject){resolve(1)});p.then(function(x){console.log(x)})//输出1</code></pre><p>大厂版：</p><pre><code class="javascript">const PENDING = &quot;pending&quot;;const FULFILLED = &quot;fulfilled&quot;;const REJECTED = &quot;rejected&quot;;function Promise(excutor) {    let that = this; // 缓存当前promise实例对象    that.status = PENDING; // 初始状态    that.value = undefined; // fulfilled状态时 返回的信息    that.reason = undefined; // rejected状态时 拒绝的原因    that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数    that.onRejectedCallbacks = []; // 存储rejected状态对应的onRejected函数    function resolve(value) { // value成功态时接收的终值        if(value instanceof Promise) {            return value.then(resolve, reject);        }        // 实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。        setTimeout(() =&gt; {            // 调用resolve 回调对应onFulfilled函数            if (that.status === PENDING) {                // 只能由pending状态 =&gt; fulfilled状态 (避免调用多次resolve reject)                that.status = FULFILLED;                that.value = value;                that.onFulfilledCallbacks.forEach(cb =&gt; cb(that.value));            }        });    }    function reject(reason) { // reason失败态时接收的拒因        setTimeout(() =&gt; {            // 调用reject 回调对应onRejected函数            if (that.status === PENDING) {                // 只能由pending状态 =&gt; rejected状态 (避免调用多次resolve reject)                that.status = REJECTED;                that.reason = reason;                that.onRejectedCallbacks.forEach(cb =&gt; cb(that.reason));            }        });    }    // 捕获在excutor执行器中抛出的异常    // new Promise((resolve, reject) =&gt; {    //     throw new Error(&#39;error in excutor&#39;)    // })    try {        excutor(resolve, reject);    } catch (e) {        reject(e);    }}Promise.prototype.then = function(onFulfilled, onRejected) {    const that = this;    let newPromise;    // 处理参数默认值 保证参数后续能够继续执行    onFulfilled =        typeof onFulfilled === &quot;function&quot; ? onFulfilled : value =&gt; value;    onRejected =        typeof onRejected === &quot;function&quot; ? onRejected : reason =&gt; {            throw reason;        };    if (that.status === FULFILLED) { // 成功态        return newPromise = new Promise((resolve, reject) =&gt; {            setTimeout(() =&gt; {                try{                    let x = onFulfilled(that.value);                    resolvePromise(newPromise, x, resolve, reject); // 新的promise resolve 上一个onFulfilled的返回值                } catch(e) {                    reject(e); // 捕获前面onFulfilled中抛出的异常 then(onFulfilled, onRejected);                }            });        })    }    if (that.status === REJECTED) { // 失败态        return newPromise = new Promise((resolve, reject) =&gt; {            setTimeout(() =&gt; {                try {                    let x = onRejected(that.reason);                    resolvePromise(newPromise, x, resolve, reject);                } catch(e) {                    reject(e);                }            });        });    }    if (that.status === PENDING) { // 等待态        // 当异步调用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中        return newPromise = new Promise((resolve, reject) =&gt; {            that.onFulfilledCallbacks.push((value) =&gt; {                try {                    let x = onFulfilled(value);                    resolvePromise(newPromise, x, resolve, reject);                } catch(e) {                    reject(e);                }            });            that.onRejectedCallbacks.push((reason) =&gt; {                try {                    let x = onRejected(reason);                    resolvePromise(newPromise, x, resolve, reject);                } catch(e) {                    reject(e);                }            });        });    }};</code></pre><p>参考：</p><p><a href="https://juejin.im/post/5c9c3989e51d454e3a3902b6#heading-15" target="_blank" rel="noopener">JavaScript手写代码无敌秘籍</a></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-router原理</title>
      <link href="/2019/10/10/vue-router%E5%8E%9F%E7%90%86/"/>
      <url>/2019/10/10/vue-router%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<!-- # vue-router原理 --><p>随着前端应用的业务功能越来越复杂、用户对于使用体验的要求越来越高，单页应用（SPA）成为前端应用的主流形式。大型单页应用最显著特点之一就是采用前端路由系统，通过改变URL，在不重新请求页面的情况下，更新页面视图。</p><p>“更新视图但不重新请求页面”是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有两种方式：</p><ul><li>利用URL中的hash（“#”）</li><li>利用History interface在 HTML5中新增的方法</li></ul><h3 id="模式参数"><a href="#模式参数" class="headerlink" title="模式参数"></a>模式参数</h3><p>在vue-router中是通过mode这一参数控制路由的实现模式的：</p><pre><code class="javascript">const router = new VueRouter({  mode: &#39;history&#39;,  routes: [...]})</code></pre><p>创建VueRouter的实例对象时，mode以构造函数参数的形式传入。带着问题阅读源码，我们就可以从VueRouter类的定义入手。一般插件对外暴露的类都是定义在源码src根目录下的index.js文件中，打开该文件，可以看到VueRouter类的定义，摘录与mode参数有关的部分如下：</p><pre><code class="javascript">export default class VueRouter {  mode: string; // 传入的字符串参数，指示history类别  history: HashHistory | HTML5History | AbstractHistory; // 实际起作用的对象属性，必须是以上三个类的枚举  fallback: boolean; // 如浏览器不支持，&#39;history&#39;模式需回滚为&#39;hash&#39;模式  constructor (options: RouterOptions = {}) {    let mode = options.mode || &#39;hash&#39; // 默认为&#39;hash&#39;模式    this.fallback = mode === &#39;history&#39; &amp;&amp; !supportsPushState // 通过supportsPushState判断浏览器是否支持&#39;history&#39;模式    if (this.fallback) {      mode = &#39;hash&#39;    }    if (!inBrowser) {      mode = &#39;abstract&#39; // 不在浏览器环境下运行需强制为&#39;abstract&#39;模式    }    this.mode = mode    // 根据mode确定history实际的类并实例化    switch (mode) {      case &#39;history&#39;:        this.history = new HTML5History(this, options.base)        break      case &#39;hash&#39;:        this.history = new HashHistory(this, options.base, this.fallback)        break      case &#39;abstract&#39;:        this.history = new AbstractHistory(this, options.base)        break      default:        if (process.env.NODE_ENV !== &#39;production&#39;) {          assert(false, `invalid mode: ${mode}`)        }    }  }  init (app: any /* Vue component instance */) {    const history = this.history    // 根据history的类别执行相应的初始化操作和监听    if (history instanceof HTML5History) {      history.transitionTo(history.getCurrentLocation())    } else if (history instanceof HashHistory) {      const setupHashListener = () =&gt; {        history.setupListeners()      }      history.transitionTo(        history.getCurrentLocation(),        setupHashListener,        setupHashListener      )    }    history.listen(route =&gt; {      this.apps.forEach((app) =&gt; {        app._route = route      })    })  }  // VueRouter类暴露的以下方法实际是调用具体history对象的方法  push (location: RawLocation, onComplete?: Function, onAbort?: Function) {    this.history.push(location, onComplete, onAbort)  }  replace (location: RawLocation, onComplete?: Function, onAbort?: Function) {    this.history.replace(location, onComplete, onAbort)  }}</code></pre><p>可以看出：</p><ol><li><p>作为参数传入的字符串属性mode只是一个标记，用来指示实际起作用的对象属性history的实现类，两者对应关系如下：</p><p>modehistory’history’HTML5History’hash’HashHistory’abstract’AbstractHistory</p></li><li><p>在初始化对应的history之前，会对mode做一些校验：若浏览器不支持HTML5History方式（通过supportsPushState变量判断），则mode强制设为’hash’；若不是在浏览器环境下运行，则mode强制设为’abstract’</p></li><li><p>VueRouter类中的onReady(), push()等方法只是一个代理，实际是调用的具体history对象的对应方法，在init()方法中初始化时，也是根据history对象具体的类别执行不同操作</p></li></ol><p>在浏览器环境下的两种方式，分别就是在HTML5History，HashHistory两个类中实现的。他们都定义在src/history文件夹下，继承自同目录下base.js文件中定义的History类。History中定义的是公用和基础的方法，直接看会一头雾水，我们先从HTML5History，HashHistory两个类中看着亲切的push(), replace()方法的说起。</p><h3 id="HashHistory"><a href="#HashHistory" class="headerlink" title="HashHistory"></a>HashHistory</h3><p>看源码前先回顾一下原理：</p><p>hash（“#”）符号的本来作用是加在URL中指示网页中的位置：</p><blockquote><p><a href="http://www.example.com/index.html#print" target="_blank" rel="noopener">http://www.example.com/index.html#print</a></p></blockquote><p>#符号本身以及它后面的字符称之为hash，可通过window.location.hash属性读取。它具有如下特点：</p><ul><li><p>hash虽然出现在URL中，但不会被包括在HTTP请求中。它是用来指导浏览器动作的，对服务器端完全无用，因此，改变hash不会重新加载页面</p></li><li><p>可以为hash的改变添加监听事件：</p><pre><code class="javascript">window.addEventListener(&quot;hashchange&quot;, funcRef, false)</code></pre></li><li><p>每一次改变hash（window.location.hash），都会在浏览器的访问历史中增加一个记录</p></li></ul><p>利用hash的以上特点，就可以来实现前端路由“更新视图但不重新请求页面”的功能了。</p><h5 id="HashHistory-push"><a href="#HashHistory-push" class="headerlink" title="HashHistory.push()"></a><strong>HashHistory.push()</strong></h5><p>我们来看HashHistory中的push()方法：</p><pre><code class="javascript">push (location: RawLocation, onComplete?: Function, onAbort?: Function) {  this.transitionTo(location, route =&gt; {    pushHash(route.fullPath)    onComplete &amp;&amp; onComplete(route)  }, onAbort)}function pushHash (path) {  window.location.hash = path}</code></pre><p>transitionTo()方法是父类中定义的是用来处理路由变化中的基础逻辑的，push()方法最主要的是对window的hash进行了直接赋值：</p><pre><code class="javascript">window.location.hash = route.fullPath</code></pre><p>hash的改变会自动添加到浏览器的访问历史记录中。</p><p>那么视图的更新是怎么实现的呢，我们来看父类History中transitionTo()方法的这么一段：</p><pre><code class="javascript">transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) {  const route = this.router.match(location, this.current)  this.confirmTransition(route, () =&gt; {    this.updateRoute(route)    ...  })}updateRoute (route: Route) {  this.cb &amp;&amp; this.cb(route)}listen (cb: Function) {  this.cb = cb}</code></pre><p>可以看到，当路由变化时，调用了History中的this.cb方法，而this.cb方法是通过History.listen(cb)进行设置的。回到VueRouter类定义中，找到了在init()方法中对其进行了设置：</p><pre><code class="javascript">export function install (Vue) {  Vue.mixin({    beforeCreate () {      if (isDef(this.$options.router)) {        this._router = this.$options.router        this._router.init(this)        Vue.util.defineReactive(this, &#39;_route&#39;, this._router.history.current)      }      registerInstance(this, this)    },  })}</code></pre><p>通过Vue.mixin()方法，全局注册一个混合，影响注册之后所有创建的每个 Vue 实例，该混合在beforeCreate钩子中通过Vue.util.defineReactive()定义了响应式的_route属性。所谓响应式属性，即当_route值改变时，会自动调用Vue实例的render()方法，更新视图。</p><p>总结一下，从设置路由改变到视图更新的流程如下：</p><pre><code>$router.push() --&gt; HashHistory.push() --&gt; History.transitionTo() --&gt; History.updateRoute() --&gt; {app._route = route} --&gt; vm.render()</code></pre><h5 id="HashHistory-replace"><a href="#HashHistory-replace" class="headerlink" title="HashHistory.replace()"></a><strong>HashHistory.replace()</strong></h5><p>replace()方法与push()方法不同之处在于，它并不是将新路由添加到浏览器访问历史的栈顶，而是替换掉当前的路由：</p><pre><code class="javascript">replace (location: RawLocation, onComplete?: Function, onAbort?: Function) {  this.transitionTo(location, route =&gt; {    replaceHash(route.fullPath)    onComplete &amp;&amp; onComplete(route)  }, onAbort)}function replaceHash (path) {  const i = window.location.href.indexOf(&#39;#&#39;)  window.location.replace(    window.location.href.slice(0, i &gt;= 0 ? i : 0) + &#39;#&#39; + path  )}</code></pre><p>可以看出，它与push()的实现结构上基本相似，不同点在于它不是直接对window.location.hash进行赋值，而是调用window.location.replace方法将路由进行替换。</p><h5 id="监听地址栏"><a href="#监听地址栏" class="headerlink" title="监听地址栏"></a><strong>监听地址栏</strong></h5><p>以上讨论的VueRouter.push()和VueRouter.replace()是可以在vue组件的逻辑代码中直接调用的，除此之外在浏览器中，用户还可以直接在浏览器地址栏中输入改变路由，因此VueRouter还需要能监听浏览器地址栏中路由的变化，并具有与通过代码调用相同的响应行为。在HashHistory中这一功能通过setupListeners实现：</p><pre><code class="javascript">setupListeners () {  window.addEventListener(&#39;hashchange&#39;, () =&gt; {    if (!ensureSlash()) {      return    }    this.transitionTo(getHash(), route =&gt; {      replaceHash(route.fullPath)    })  })}</code></pre><p>该方法设置监听了浏览器事件hashchange，调用的函数为replaceHash，即在浏览器地址栏中直接输入路由相当于代码调用了replace()方法。</p><h3 id="HTML5History"><a href="#HTML5History" class="headerlink" title="HTML5History"></a>HTML5History</h3><p>History interface是浏览器历史记录栈提供的接口，通过back(), forward(), go()等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。</p><p>从HTML5开始，History interface提供了两个新的方法：pushState(), replaceState()使得我们可以对浏览器历史记录栈进行修改：</p><pre><code class="javascript">window.history.pushState(stateObject, title, URL)window.history.replaceState(stateObject, title, URL)</code></pre><ul><li>stateObject: 当浏览器跳转到新的状态时，将触发popState事件，该事件将携带这个stateObject参数的副本</li><li>title: 所添加记录的标题</li><li>URL: 所添加记录的URL</li></ul><p>这两个方法有个共同的特点：当调用他们修改浏览器历史记录栈后，虽然当前URL改变了，但浏览器不会立即发送请求该URL（the browser won’t attempt to load this URL after a call to pushState()），这就为单页应用前端路由“更新视图但不重新请求页面”提供了基础。</p><p>我们来看vue-router中的源码：</p><pre><code class="javascript">push (location: RawLocation, onComplete?: Function, onAbort?: Function) {  const { current: fromRoute } = this  this.transitionTo(location, route =&gt; {    pushState(cleanPath(this.base + route.fullPath))    handleScroll(this.router, route, fromRoute, false)    onComplete &amp;&amp; onComplete(route)  }, onAbort)}replace (location: RawLocation, onComplete?: Function, onAbort?: Function) {  const { current: fromRoute } = this  this.transitionTo(location, route =&gt; {    replaceState(cleanPath(this.base + route.fullPath))    handleScroll(this.router, route, fromRoute, false)    onComplete &amp;&amp; onComplete(route)  }, onAbort)}// src/util/push-state.jsexport function pushState (url?: string, replace?: boolean) {  saveScrollPosition()  // try...catch the pushState call to get around Safari  // DOM Exception 18 where it limits to 100 pushState calls  const history = window.history  try {    if (replace) {      history.replaceState({ key: _key }, &#39;&#39;, url)    } else {      _key = genKey()      history.pushState({ key: _key }, &#39;&#39;, url)    }  } catch (e) {    window.location[replace ? &#39;replace&#39; : &#39;assign&#39;](url)  }}export function replaceState (url?: string) {  pushState(url, true)}</code></pre><p>代码结构以及更新视图的逻辑与hash模式基本类似，只不过将对window.location.hash直接进行赋值window.location.replace()改为了调用history.pushState()和history.replaceState()方法。</p><p>在HTML5History中添加对修改浏览器地址栏URL的监听是直接在构造函数中执行的：</p><pre><code class="javascript">constructor (router: Router, base: ?string) {  window.addEventListener(&#39;popstate&#39;, e =&gt; {    const current = this.current    this.transitionTo(getLocation(this.base), route =&gt; {      if (expectScroll) {        handleScroll(router, route, current, true)      }    })  })}</code></pre><p>当然了HTML5History用到了HTML5的新特特性，是需要特定浏览器版本的支持的，前文已经知道，浏览器是否支持是通过变量supportsPushState来检查的：</p><pre><code class="javascript">// src/util/push-state.jsexport const supportsPushState = inBrowser &amp;&amp; (function () {  const ua = window.navigator.userAgent  if (    (ua.indexOf(&#39;Android 2.&#39;) !== -1 || ua.indexOf(&#39;Android 4.0&#39;) !== -1) &amp;&amp;    ua.indexOf(&#39;Mobile Safari&#39;) !== -1 &amp;&amp;    ua.indexOf(&#39;Chrome&#39;) === -1 &amp;&amp;    ua.indexOf(&#39;Windows Phone&#39;) === -1  ) {    return false  }  return window.history &amp;&amp; &#39;pushState&#39; in window.history})()</code></pre><p>以上就是hash模式与history模式源码的导读，这两种模式都是通过浏览器接口实现的，除此之外vue-router还为非浏览器环境准备了一个abstract模式，其原理为用一个数组stack模拟出浏览器历史记录栈的功能。当然，以上只是一些核心逻辑，为保证系统的鲁棒性源码中还有大量的辅助逻辑，也很值得学习。此外在vue-router中还有路由匹配、router-view视图组件等重要部分，关于整体源码的阅读推荐滴滴前端的<a href="https://zhuanlan.zhihu.com/p/24574970" target="_blank" rel="noopener">这篇文章</a>。</p><h3 id="两种模式比较"><a href="#两种模式比较" class="headerlink" title="两种模式比较"></a>两种模式比较</h3><p>在一般的需求场景中，hash模式与history模式是差不多的，但几乎所有的文章都推荐使用history模式，理由竟然是：”#” 符号太丑…0_0 “</p><blockquote><p>如果不想要很丑的 hash，我们可以用路由的 history 模式 ——官方文档</p></blockquote><p>当然，严谨的我们肯定不应该用颜值评价技术的好坏。根据MDN的介绍，调用history.pushState()相比于直接修改hash主要有以下优势：</p><ul><li>pushState设置的新URL可以是与当前URL同源的任意URL；而hash只可修改#后面的部分，故只可设置与当前同文档的URL</li><li>pushState设置的新URL可以与当前URL一模一样，这样也会把记录添加到栈中；而hash设置的新值必须与原来不一样才会触发记录添加到栈中</li><li>pushState通过stateObject可以添加任意类型的数据到记录中；而hash只可添加短字符串</li><li>pushState可额外设置title属性供后续使用</li></ul><h4 id="history模式的一个问题"><a href="#history模式的一个问题" class="headerlink" title="history模式的一个问题"></a><strong>history模式的一个问题</strong></h4><p>我们知道对于单页应用来讲，理想的使用场景是仅在进入应用时加载index.html，后续在的网络操作通过Ajax完成，不会根据URL重新请求页面，但是难免遇到特殊情况，比如用户直接在地址栏中输入并回车，浏览器重启重新加载应用等。</p><p>hash模式仅改变hash部分的内容，而hash部分是不会包含在HTTP请求中的：</p><pre><code class="text">http://oursite.com/#/user/id   // 如重新请求只会发送http://oursite.com/</code></pre><p>故在hash模式下遇到根据URL请求页面的情况不会有问题。</p><p>而history模式则会将URL修改得就和正常请求后端的URL一样</p><pre><code class="text">http://oursite.com/user/id</code></pre><p>在此情况下重新向后端发送请求，如后端没有配置对应/user/id的路由处理，则会返回404错误。官方推荐的解决办法是在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。同时这么做以后，服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。或者，如果是用 Node.js 作后台，可以使用服务端的路由来匹配 URL，当没有匹配到路由的时候返回 404，从而实现 fallback。</p><h3 id="直接加载应用文件"><a href="#直接加载应用文件" class="headerlink" title="直接加载应用文件"></a>直接加载应用文件</h3><blockquote><p>Tip: built files are meant to be served over an HTTP server.</p><p>Opening index.html over file:// won’t work.</p></blockquote><p>Vue项目通过vue-cli的webpack打包完成后，命令行会有这么一段提示。通常情况，无论是开发还是线上，前端项目都是通过服务器访问，不存在 “Opening index.html over file://“ ，但程序员都知道，需求和场景永远是千奇百怪的，只有你想不到的，没有产品经理想不到的。</p><p>本文写作的初衷就是遇到了这样一个问题：需要快速开发一个移动端的展示项目，决定采用WebView加载Vue单页应用的形式，但没有后端服务器提供，所以所有资源需从本地文件系统加载：</p><pre><code class="javascript">// AndroidAppWrapperpublic class MainActivity extends AppCompatActivity {    private WebView webView;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        webView = new WebView(this);        webView.getSettings().setJavaScriptEnabled(true);        webView.loadUrl(&quot;file:///android_asset/index.html&quot;);        setContentView(webView);    }    @Override    public boolean onKeyDown(int keyCode, KeyEvent event) {        if ((keyCode == KeyEvent.KEYCODE_BACK) &amp;&amp; webView.canGoBack()) {            webView.goBack();            return true;        }        return false;    }}</code></pre><p>此情此景看来是必须 “Opening index.html over file://“ 了，为此，我首先要进行了一些设置</p><ul><li>在项目config.js文件中将assetsPublicPath字段的值改为相对路径 ‘./‘</li><li>调整生成的static文件夹中图片等静态资源的位置与代码中的引用地址一致</li></ul><p>这是比较明显的需要改动之处，但改完后依旧无法顺利加载，经过反复排查发现，项目在开发时，router设置为了history模式（为了美观…0_0”），当改为hash模式后就可正常加载了。</p><p>为什么会出现这种情况呢？我分析原因可能如下：</p><p>当从文件系统中直接加载index.html时，URL为：</p><pre><code>file:///android_asset/index.html</code></pre><p>而首页视图需匹配的路径为path: ‘/‘ :</p><pre><code class="javascript">export default new Router({  mode: &#39;history&#39;,  routes: [    {      path: &#39;/&#39;,      name: &#39;index&#39;,      component: IndexView    }  ]})</code></pre><p>我们先来看history模式，在HTML5History中：</p><pre><code class="typescript">ensureURL (push?: boolean) {  if (getLocation(this.base) !== this.current.fullPath) {    const current = cleanPath(this.base + this.current.fullPath)    push ? pushState(current) : replaceState(current)  }}export function getLocation (base: string): string {  let path = window.location.pathname  if (base &amp;&amp; path.indexOf(base) === 0) {    path = path.slice(base.length)  }  return (path || &#39;/&#39;) + window.location.search + window.location.hash}</code></pre><p>逻辑只会确保存在URL，path是通过剪切的方式直接从window.location.pathname获取到的，它的结尾是index.html，因此匹配不到 ‘/‘ ，故 “Opening index.html over file:// won’t work” 。</p><p>再看hash模式，在HashHistory中：</p><pre><code class="typescript">export class HashHistory extends History {  constructor (router: Router, base: ?string, fallback: boolean) {    ...    ensureSlash()  }  // this is delayed until the app mounts  // to avoid the hashchange listener being fired too early  setupListeners () {    window.addEventListener(&#39;hashchange&#39;, () =&gt; {      if (!ensureSlash()) {        return      }      ...    })  }  getCurrentLocation () {    return getHash()  }}function ensureSlash (): boolean {  const path = getHash()  if (path.charAt(0) === &#39;/&#39;) {    return true  }  replaceHash(&#39;/&#39; + path)  return false}export function getHash (): string {  const href = window.location.href  const index = href.indexOf(&#39;#&#39;)  return index === -1 ? &#39;&#39; : href.slice(index + 1)}</code></pre><p>我们看到在代码逻辑中，多次出现一个函数ensureSlash()，当#符号后紧跟着的是’/‘，则返回true，否则强行插入这个’/‘，故我们可以看到，即使是从文件系统打开index.html，URL依旧会变为以下形式：</p><pre><code>file:///C:/Users/dist/index.html#/</code></pre><p>getHash()方法返回的path为 ‘/‘ ，可与首页视图的路由匹配。</p><p>故要想从文件系统直接加载Vue单页应用而不借助后端服务器，除了打包后的一些路径设置外，还需确保vue-router使用的是hash模式。</p><p>【参考】：</p><p><a href="https://zhuanlan.zhihu.com/p/27588422" target="_blank" rel="noopener">【源码拾遗】从vue-router看前端路由的两种实现</a></p><p><a href="https://www.jianshu.com/p/4295aec31302" target="_blank" rel="noopener">浅谈vue-router原理</a></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue项目中 img标签加载失败</title>
      <link href="/2019/10/10/vue%E4%B8%ADimg%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5/"/>
      <url>/2019/10/10/vue%E4%B8%ADimg%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<!-- # vue项目中 img标签加载失败 --><h5 id="第一种方法：加载失败，直接删除img标签"><a href="#第一种方法：加载失败，直接删除img标签" class="headerlink" title="第一种方法：加载失败，直接删除img标签"></a>第一种方法：加载失败，直接删除img标签</h5><pre><code>&lt; img src=“123” :οnerrοr=“defaultImg” /&gt;默认图地址defaultImg: ‘this.remove()’</code></pre><h5 id="第二种方法：替换默认图片"><a href="#第二种方法：替换默认图片" class="headerlink" title="第二种方法：替换默认图片"></a>第二种方法：替换默认图片</h5><pre><code>&lt; img src=“123” @error=“defImg()” /&gt;默认图地址defaultImg: require(&quot;./img/defPic.png&quot;)defImg(){     let img = event.srcElement;     img.src = this.defaultImg;     img.onerror = null; //防止闪图}</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>element-ui文件上传 做类型大小的限制</title>
      <link href="/2019/10/09/element-ui%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%20%E5%81%9A%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F%E7%9A%84%E9%99%90%E5%88%B6/"/>
      <url>/2019/10/09/element-ui%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%20%E5%81%9A%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F%E7%9A%84%E9%99%90%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<!-- # element-ui文件上传 做类型大小的限制 --><pre><code class="html">&lt;div class=&quot;filebox&quot;&gt;    &lt;el-upload class=&quot;upload-demo&quot; :action=&quot;url&quot; :on-preview=&quot;handlePreview&quot; :on-remove=&quot;handleRemove&quot; multiple :limit=&quot;limitnum&quot; :on-exceed=&quot;handleExceed&quot; :file-list=&quot;fileList&quot; :beforeUpload=&quot;beforeAvatarUpload&quot;&gt;        &lt;el-button size=&quot;mini&quot; type=&quot;primary&quot;&gt;点击上传&lt;/el-button&gt;        &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;只能上传jpg/png文件，且不超过500kb&lt;/div&gt;    &lt;/el-upload&gt;&lt;/div&gt;</code></pre><pre><code>:beforeUpload=&quot;beforeAvatarUpload&quot;</code></pre><p><strong>methods里面写beforeAvatarUpload这个方法</strong></p><pre><code class="javascript">beforeAvatarUpload(file) {                     var testmsg = file.name.substring(file.name.lastIndexOf(&#39;.&#39;)+1);                const extension = testmsg === &#39;xls&#39;;    const extension2 = testmsg === &#39;xlsx&#39;;    const isLt2M = file.size / 1024 / 1024 &lt; 10;    if(!extension &amp;&amp; !extension2) {        this.$message({            message: &#39;上传文件只能是 xls、xlsx格式!&#39;,            type: &#39;warning&#39;        });    }    if(!isLt2M) {        this.$message({            message: &#39;上传文件大小不能超过 10MB!&#39;,            type: &#39;warning&#39;        });    }    return extension || extension2 &amp;&amp; isLt2M}</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端 1px 像素问题及解决办法</title>
      <link href="/2019/10/09/%E7%A7%BB%E5%8A%A8%E7%AB%AF1px%E9%97%AE%E9%A2%98/"/>
      <url>/2019/10/09/%E7%A7%BB%E5%8A%A8%E7%AB%AF1px%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<!-- # 移动端 1px 像素问题及解决办法 --><h3 id="一、为什么会有1px问题"><a href="#一、为什么会有1px问题" class="headerlink" title="一、为什么会有1px问题"></a>一、为什么会有1px问题</h3><p>那么为什么会产生这个问题呢？主要是跟一个东西有关，DPR(devicePixelRatio) 设备像素比，它是默认缩放为100%的情况下，设备像素和CSS像素的比值。</p><pre><code>window.devicePixelRatio = 物理像素 /CSS像素</code></pre><p>目前主流的屏幕DPR=2 （iPhone 8）,或者3 （iPhone 8 Plus）。拿2倍屏来说，设备的物理像素要实现1像素，而DPR=2，所以css 像素只能是 0.5。一般设计稿是按照750来设计的，它上面的1px是以750来参照的，而我们写css样式是以设备375为参照的，所以我们应该写的0.5px就好了啊！ 试过了就知道，iOS 8+系统支持，安卓系统不支持。</p><h3 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h3><h5 id="1、直接设置0-5px"><a href="#1、直接设置0-5px" class="headerlink" title="1、直接设置0.5px"></a>1、直接设置0.5px</h5><p> 媒体查询利用设备像素比缩放，设置小数像素。</p><p>优点：简单，好理解<br>缺点：兼容性差，目前之余IOS8+才支持，在IOS7及其以下、安卓系统都是显示0px。</p><blockquote><p>IOS8+下已经支持带小数的px值，media query 对应 devicePixelRatio 有个查询值 -webkit-min-device-pixel-ratio；</p></blockquote><ul><li>1）设置css：</li></ul><pre><code class="css">.border { border: 1px solid #999 }@media screen and (-webkit-min-device-pixel-ratio: 2) {    .border { border: 0.5px solid #999 }}@media screen and (-webkit-min-device-pixel-ratio: 3) {    .border { border: 0.333333px solid #999 }}</code></pre><ul><li>2）设置js：</li></ul><pre><code class="html">&lt;body&gt;    &lt;div id=&quot;main&quot; style=&quot;border: 1px solid #000000;&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt;    if (window.devicePixelRatio &amp;&amp; devicePixelRatio &gt;= 2) {        var main = document.getElementById(&#39;main&#39;);        main.style.border = &#39;.5px solid #000000&#39;;    }&lt;/script&gt;</code></pre><h5 id="2、使用边框图片"><a href="#2、使用边框图片" class="headerlink" title="2、使用边框图片"></a>2、使用边框图片</h5><p>缺点：需要制作图片，圆角可能出现模糊</p><pre><code class="css">.border-image-1px {    border-width: 1px 0px;    -webkit-border-image: url(&quot;border.png&quot;) 2 0 stretch;    border-image: url(&quot;border.png&quot;) 2 0 stretch;}</code></pre><ul><li><code>border-width</code>：指定边框的宽度，可以设定四个值，分别为上右下左border-width: top right bottom left。</li><li><code>border-image</code>：该例意为：距离图片上方2px（属性值上没有单位）裁剪边框图片作为上边框，下方2px裁剪作为下边框。距离左右0像素裁剪图片即没有边框，以拉伸方式展示。</li></ul><h5 id="3、多背景渐变实现"><a href="#3、多背景渐变实现" class="headerlink" title="3、多背景渐变实现"></a>3、多背景渐变实现</h5><p>除了使用图片外，当然也能使用纯css来实现，百度糯米团就是采用的这种方案。<br>缺点：因为每个边框都是线性渐变颜色实现，因此无法实现圆角。</p><pre><code class="css">.border {      background-image:linear-gradient(180deg, red, red 50%, transparent 50%),      linear-gradient(270deg, red, red 50%, transparent 50%),      linear-gradient(0deg, red, red 50%, transparent 50%),      linear-gradient(90deg, red, red 50%, transparent 50%);      background-size: 100% 1px,1px 100% ,100% 1px, 1px 100%;      background-repeat: no-repeat;      background-position: top, right top,  bottom, left top;      padding: 10px;}</code></pre><ul><li>原理：将原本1个物理像素的边框大小利用线性渐变分割成几个部分（百分比控制），实现小于1像素效果。</li><li><code>linear-gradient</code>：指定线性渐变，接受大于等于3个参数，第一个为渐变旋转角度，第二个开始为渐变的颜色和到哪个位置（百分比）全部变为该颜色，该例子中，第一句就是，渐变方向旋转180度，即从上往下（默认为0度从下往上），从红色开始渐变，到50%的位置还是红色，再渐变为继承父元素颜色。</li></ul><h5 id="4、box-shadow实现"><a href="#4、box-shadow实现" class="headerlink" title="4、box-shadow实现"></a>4、box-shadow实现</h5><p>利用阴影也可以实现，优点是没有圆角问题，缺点是颜色不好控制</p><pre><code class="css">div {    -webkit-box-shadow: 0 1px 1px -1px rgba(0, 0, 0, 0.5);}div {    box-shadow: 0  -1px 1px -1px #e5e5e5,   //上边线            1px  0  1px -1px #e5e5e5,   //右边线            0  1px  1px -1px #e5e5e5,   //下边线            -1px 0  1px -1px #e5e5e5;   //左边线}</code></pre><ul><li>box-shadow属性的用法：<code>box-shadow: h-shadow v-shadow [blur] [spread] [color] [inset]</code></li></ul><p>参数分别表示: 水平阴影位置，垂直阴影位置，模糊距离， 阴影尺寸，阴影颜色，将外部阴影改为内部阴影，后四个可选。该例中为何将阴影尺寸设置为负数？设置成-1px 是为了让阴影尺寸稍小于div元素尺寸，这样左右两边的阴影就不会暴露出来，实现只有底部一边有阴影的效果。从而实现分割线效果（单边边框）。</p><h5 id="5、viewport-rem实现-推荐"><a href="#5、viewport-rem实现-推荐" class="headerlink" title="5、viewport + rem实现 - 推荐"></a>5、viewport + rem实现 - 推荐</h5><p>该方案是对上述方案的优化，整体思路就是利用viewport + rem + js 动态的修改页面的缩放比例，实现小于1像素的显示。</p><ul><li>优点：全机型兼容，直接写<code>1px</code>不能再方便</li><li>缺点：适用于新的项目，老项目可能改动大</li></ul><pre><code class="html">&lt;meta name=&quot;viewport&quot; id=&quot;WebViewport&quot; content=&quot;initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;&gt;&lt;style&gt;    html {        font-size: 1px;    }     .top_b {        border-bottom: 1px solid #E5E5E5;    }&lt;/style&gt;&lt;script&gt;    var viewport = document.querySelector(&quot;meta[name=viewport]&quot;);    //下面是根据设备像素设置viewport    if (window.devicePixelRatio == 1) {        viewport.setAttribute(&#39;content&#39;, &#39;width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&#39;);    }    if (window.devicePixelRatio == 2) {        viewport.setAttribute(&#39;content&#39;, &#39;width=device-width,initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&#39;);    }    if (window.devicePixelRatio == 3) {        viewport.setAttribute(&#39;content&#39;, &#39;width=device-width,initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no&#39;);    }    var docEl = document.documentElement;    var fontsize = 32* (docEl.clientWidth / 750) + &#39;px&#39;;    docEl.style.fontSize = fontsize;&lt;/script&gt;</code></pre><h5 id="6、伪类-transform-scale-0-5-方案-推荐"><a href="#6、伪类-transform-scale-0-5-方案-推荐" class="headerlink" title="6、伪类 + transform: scale(0.5) 方案 - 推荐"></a>6、伪类 + transform: scale(0.5) 方案 - 推荐</h5><ul><li>优点：全机型兼容，实现了真正的1px，而且可以圆角。</li><li>缺点：暂用了after 伪元素，可能影响清除浮动。</li></ul><pre><code class="css">// 1)设置height: 1px，根据媒体查询结合transform缩放为相应尺寸。div {    height:1px;    background:#000;    -webkit-transform: scaleY(0.5);    -webkit-transform-origin:0 0;    overflow: hidden;}// 2)用::after和::befor,设置border-bottom：1px solid #000,然后在缩放-webkit-transform: scaleY(0.5);可以实现两根边线的需求div::after{    content:&#39;&#39;;width:100%;    border-bottom:1px solid #000;    transform: scaleY(0.5);}// 3)用::after设置border：1px solid #000; width:200%; height:200%,然后再缩放scaleY(0.5); 优点可以实现圆角，京东就是这么实现的，缺点是按钮添加active比较麻烦。.div::after {    content: &#39;&#39;;    width: 200%;    height: 200%;    position: absolute;    top: 0;    left: 0;    border: 1px solid #bfbfbf;    border-radius: 4px;    -webkit-transform: scale(0.5,0.5);    transform: scale(0.5,0.5);    -webkit-transform-origin: top left;}</code></pre><p>1 条border：将伪元素设置绝对定位，并且和父元素的左上角对齐，将width 设置100%，height设置为1px，然后进行在Y方向缩小<code>0.5倍</code>。</p><pre><code class="less">.setOnePx{  position: relative;  &amp;::after{    position: absolute;    content: &#39;&#39;;    background-color: #e5e5e5;    display: block;    width: 100%;    height: 1px; /*no*/    transform: scale(1, 0.5);    top: 0;    left: 0;  }}</code></pre><p>4 条border：同样为伪元素设置绝对定位，并且和父元素左上角对其。将伪元素的长和宽先放大2倍，然后再设置一个边框，以左上角为中心，缩放到原来的<code>0.5倍</code></p><pre><code class="less">.setBorderAll{    position: relative;       &amp;:after{           content:&quot; &quot;;           position:absolute;           top: 0;           left: 0;           width: 200%;           height: 200%;           transform: scale(0.5);           transform-origin: left top;           box-sizing: border-box;           border: 1px solid #E5E5E5;           border-radius: 4px;      }}</code></pre><h5 id="7、媒体查询-transfrom-对方案1的优化"><a href="#7、媒体查询-transfrom-对方案1的优化" class="headerlink" title="7、媒体查询 + transfrom 对方案1的优化"></a>7、媒体查询 + transfrom 对方案1的优化</h5><pre><code class="css">/* 2倍屏 */@media only screen and (-webkit-min-device-pixel-ratio: 2.0) {    .border-bottom::after {        -webkit-transform: scaleY(0.5);        transform: scaleY(0.5);    }}/* 3倍屏 */@media only screen and (-webkit-min-device-pixel-ratio: 3.0) {    .border-bottom::after {        -webkit-transform: scaleY(0.33);        transform: scaleY(0.33);    }}</code></pre><h5 id="8、使用pxtoviewport"><a href="#8、使用pxtoviewport" class="headerlink" title="8、使用pxtoviewport"></a>8、使用pxtoviewport</h5><p>配置移动单位转换插件 <code>postcss-px-to-viewport</code> 。</p><p>缺点：兼容性不好，时有时无。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何disabled禁用所有表单input输入框元素</title>
      <link href="/2019/10/09/%E5%A6%82%E4%BD%95disabled%E7%A6%81%E7%94%A8%E6%89%80%E6%9C%89%E8%A1%A8%E5%8D%95input%E8%BE%93%E5%85%A5%E6%A1%86%E5%85%83%E7%B4%A0/"/>
      <url>/2019/10/09/%E5%A6%82%E4%BD%95disabled%E7%A6%81%E7%94%A8%E6%89%80%E6%9C%89%E8%A1%A8%E5%8D%95input%E8%BE%93%E5%85%A5%E6%A1%86%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<!-- ## 如何disabled禁用所有表单input输入框元素 --><p>参考：<a href="https://www.zhangxinxu.com/wordpress/2019/04/disabled-all-form-elements/" target="_blank" rel="noopener">如何disabled禁用所有表单input输入框元素</a></p><h3 id="pointer-events-none和覆盖层方法的问题"><a href="#pointer-events-none和覆盖层方法的问题" class="headerlink" title="pointer-events:none和覆盖层方法的问题"></a>pointer-events:none和覆盖层方法的问题</h3><p>经常会遇到需求，需要禁用<code>div</code>中或者<code>form</code>元素中一堆表单控件元素，如<code>&lt;input&gt;</code>，<code>&lt;select&gt;</code>，<code>&lt;textarea&gt;</code>元素。</p><p>很多人用的下面这两种方法实现：</p><ol><li><p>设置</p><pre><code>pointer-events:none</code></pre><p>，该声明不了解可参见“<a href="https://www.zhangxinxu.com/wordpress/2011/12/css3-pointer-events-none-javascript/" target="_blank" rel="noopener">CSS3 pointer-events:none应用举例及扩展</a>”这篇文章。例如：</p><pre><code>form {  pointer-events: none;}</code></pre></li><li><p>使用</p><pre><code>::before</code></pre><p>伪元素创建一个浮层该在所有的表单元素上，例如：</p><pre><code>form {  position: relative;}form::before {  content: &#39;&#39;;  position: absolute;  left: 0; right: 0; top: 0; bottom: 0;  background-color: rgba(0,0,0,.001);}</code></pre></li></ol><p>以上两个方向虽然可以让点击无效，但是并没有阻止键盘访问，也就是Tab键索引，或者回车都能触发表单行为，使用<code>new FormData(form)</code>也能获取表单控件值，并不是真正意义上禁用，问题很大。</p><h3 id="fieldset元素轻松实现"><a href="#fieldset元素轻松实现" class="headerlink" title="fieldset元素轻松实现"></a>fieldset元素轻松实现</h3><p>其实，要真正意义上禁用所有的表单元素很简单，嵌套在<code>&lt;fieldset&gt;</code>元素中，然后设置<code>&lt;fieldset&gt;</code>元素<code>disabled</code>就可以了，代码示意如下：</p><pre><code>&lt;form&gt;    &lt;fieldset disabled&gt;        &lt;legend&gt;表单标题&lt;/legend&gt;        &lt;...&gt;    &lt;/fieldset&gt;&lt;/form&gt;</code></pre><p>回家吧，结束了！</p><h3 id="IE浏览器的瑕疵和解决"><a href="#IE浏览器的瑕疵和解决" class="headerlink" title="IE浏览器的瑕疵和解决"></a>IE浏览器的瑕疵和解决</h3><p>然后，IE浏览器（包括Edge）下有个瑕疵，那就是UI样式上虽然禁用了，键盘也无法响应，但是，输入框内容居然可以输入，而且表单的提交行为居然也可以点击触发，有些不完美，怎么办呢？</p><p>可以再辅助下面的CSS：</p><pre><code>fieldset[disabled] {   -ms-pointer-events: none;   pointer-events: none;}</code></pre><p>IE10+浏览器都可以完美禁用。</p><p>有人要问如果我要兼容IE8，IE9浏览器怎么办？</p><p>那使用伪元素创建一个浮层覆盖在所有表单元素上面，就是一开始提到的覆盖方法，具体代码不重复展示。</p><p>于是，双管齐下，表单所有元素禁用就这样完美搞定了。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue获取当前页面的 IP地址</title>
      <link href="/2019/10/09/vue%E4%B8%8B%EF%BC%8C%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E9%A1%B5%E9%9D%A2%E7%9A%84IP/"/>
      <url>/2019/10/09/vue%E4%B8%8B%EF%BC%8C%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E9%A1%B5%E9%9D%A2%E7%9A%84IP/</url>
      
        <content type="html"><![CDATA[<!-- # 使用Vue，获取当前页面的 IP地址 --><p>使用vue引入外部js。（这里是使用搜狐的api来获取用户的ip）</p><p>如果是单纯的html，我们引入js很简单直接</p><pre><code class="html">&lt;script src=&quot;http://pv.sohu.com/cityjson?ie=utf-8&quot;&gt;&lt;/script&gt;</code></pre><p>但是vue不可以这样。</p><ol><li><p>在你要用到js的页面的components加入下面的代码</p><pre><code class="javascript">components: {    &#39;remote-js&#39;: {        render(createElement) {            return createElement(&#39;script&#39;, { attrs: { type: &#39;text/javascript&#39;, src: this.src }});        },        props: {            src: { type: String, required: true },        },    },}</code></pre></li><li><p>在当前页面的模板中放入相关js</p><pre><code class="html">&lt;template&gt;    &lt;remote-js src=&quot;http://pv.sohu.com/cityjson?ie=utf-8&quot;&gt;&lt;/remote-js&gt;&lt;/template&gt;</code></pre></li><li><p>调用相关方法来获取ip</p><pre><code class="javascript">var user_ip = returnCitySN[&quot;cip&quot;];</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Axiso解决跨域访问</title>
      <link href="/2019/10/09/Axiso%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE/"/>
      <url>/2019/10/09/Axiso%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<!-- # Axiso解决跨域访问 --><p>首先请检查下你的 Vue 版本，Vue2 和 Vue3 跨域方式不同：</p><pre><code>$ vue -V2.X or 3.X</code></pre><h3 id="一、Vue2-版本"><a href="#一、Vue2-版本" class="headerlink" title="一、Vue2 版本"></a>一、Vue2 版本</h3><p>这里以访问 Ve2x 的一个公告API为例，直接访问如下：</p><pre><code class="javascript">this.$axios.get(&quot;https://www.v2ex.com/api/site/info.json&quot;).then(res=&gt;{    console.log(res)}).catch(err=&gt;{    console.log(err)})</code></pre><p>当我们运行程序后，控制台报错如下：</p><p><img src="http://qab0509yb.bkt.clouddn.com/201910091.png" alt=""></p><p>可以看到浏览器拦截了我们的请求，因为我们跨域了，下面解决跨域问题。</p><p><strong>Step1：配置BaseUrl</strong></p><p>首先在<code>main.js</code>中，配置下我们访问的Url前缀：</p><pre><code class="javascript">import Vue from &#39;vue&#39;import App from &#39;./App&#39;import Axios from &#39;axios&#39;Vue.prototype.$axios = AxiosAxios.defaults.baseURL = &#39;/api&#39;Axios.defaults.headers.post[&#39;Content-Type&#39;] = &#39;application/json&#39;;Vue.config.productionTip = false/* eslint-disable no-new */new Vue({  el: &#39;#app&#39;,  components: { App },  template: &#39;&lt;App/&gt;&#39;})</code></pre><p>关键代码是：<code>Axios.defaults.baseURL = &#39;/api&#39;</code>，这样每次发送请求都会带一个<code>/api</code>的前缀。</p><p><strong>Step2：配置代理</strong></p><p>修改config文件夹下的<code>index.js</code>文件，在<code>proxyTable</code>中加上如下代码：</p><pre><code class="javascript">&#39;/api&#39;:{    target: &quot;https://www.v2ex.com/api&quot;,    changeOrigin:true,    pathRewrite:{        &#39;^/api&#39;:&#39;&#39;    }}</code></pre><p><strong>Step3：修改请求Url</strong></p><p>修改刚刚的axios请求，把<code>url</code>修改如下：</p><pre><code class="javascript">this.$axios.get(&quot;/site/info.json&quot;).then(res=&gt;{    console.log(res)}).catch(err=&gt;{    console.log(err)})</code></pre><p><strong>Step4：重启服务</strong></p><p><strong>重启服务</strong>后，此时已经能够访问了：</p><p><img src="http://qab0509yb.bkt.clouddn.com/201910092.png" alt=""></p><p>原理：</p><p>因为我们给url加上了前缀 /api，我们访问 <a href="http://127.0.0.1:19323/site/info.json" target="_blank" rel="noopener">http://127.0.0.1:19323/site/info.json</a> 就当于访问了：<a href="http://127.0.0.1:19323/api/site/info.json。" target="_blank" rel="noopener">http://127.0.0.1:19323/api/site/info.json。</a>(假设本地访问端口号为 19323)</p><p>又因为在 index.js 中的 proxyTable 中拦截了 /api ,并把 /api 及其前面的所有替换成了 target 中的内容，因此实际访问 Url 是<a href="https://www.v2ex.com/api/site/info.json。" target="_blank" rel="noopener">https://www.v2ex.com/api/site/info.json。</a></p><h3 id="二、Vue3-版本"><a href="#二、Vue3-版本" class="headerlink" title="二、Vue3 版本"></a>二、Vue3 版本</h3><p>升级到 Vue3 后，会发现 Vue2 中存放配置的 <code>config</code> 文件夹没有了，大家不要慌张。可以在 package.json 文件的同级目录下创建 <code>vue.config.js</code> 文件。给出该文件的基础配置：</p><pre><code class="javascript">module.exports = {    outputDir: &#39;dist&#39;,   //build输出目录    assetsDir: &#39;assets&#39;, //静态资源目录（js, css, img）    lintOnSave: false, //是否开启eslint    devServer: {        open: true, //是否自动弹出浏览器页面        host: &quot;localhost&quot;,         port: &#39;8081&#39;,         https: false,   //是否使用https协议        hotOnly: false, //是否开启热更新        proxy: null,    }}</code></pre><blockquote><p>Vue3 解决跨域，内容只有第二步<strong>配置代理</strong> 和 Vue2 不同，其他的一致。</p></blockquote><p><strong>Step2：配置代理</strong></p><p>修改 vue.config.js 中 <code>devServer</code> 子节点内容，添加一个 <code>proxy</code>：</p><pre><code class="javascript">devServer: {    open: true, //是否自动弹出浏览器页面    host: &quot;localhost&quot;,     port: &#39;8081&#39;,    https: false,    hotOnly: false,     proxy: {        &#39;/api&#39;: {            target: &#39;https://www.v2ex.com/api&#39;, //API服务器的地址            changeOrigin: true,            pathRewrite: {                &#39;^/api&#39;: &#39;&#39;            }        }    },}</code></pre><h3 id="三、番外"><a href="#三、番外" class="headerlink" title="三、番外"></a>三、番外</h3><p>当然，跨域问题也可以由后端解决，将下面这个过滤器加入程序即可。</p><pre><code class="javascript">import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * 跨域过滤器 * @author jitwxs * @since 2018/10/16 20:53 */public class CorsFilter implements Filter {    @Override    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {        HttpServletResponse response = (HttpServletResponse) res;        HttpServletRequest request = (HttpServletRequest) req;        // 不使用*，自动适配跨域域名，避免携带Cookie时失效        String origin = request.getHeader(&quot;Origin&quot;);        if(StringUtils.isNotBlank(origin)) {            response.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin);        }        // 自适应所有自定义头        String headers = request.getHeader(&quot;Access-Control-Request-Headers&quot;);        if(StringUtils.isNotBlank(headers)) {            response.setHeader(&quot;Access-Control-Allow-Headers&quot;, headers);            response.setHeader(&quot;Access-Control-Expose-Headers&quot;, headers);        }        // 允许跨域的请求方法类型        response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;*&quot;);        // 预检命令（OPTIONS）缓存时间，单位：秒        response.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;);        // 明确许可客户端发送Cookie，不允许删除字段即可        response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);        chain.doFilter(request, response);    }    @Override    public void init(FilterConfig filterConfig) {    }    @Override    public void destroy() {    }    /*    注册过滤器：    @Bean    public FilterRegistrationBean registerFilter() {        FilterRegistrationBean&lt;CorsFilter&gt; bean = new FilterRegistrationBean&lt;&gt;();        bean.addUrlPatterns(&quot;/*&quot;);        bean.setFilter(new CorsFilter());        // 过滤顺序，从小到大依次过滤        bean.setOrder(Ordered.HIGHEST_PRECEDENCE);        return bean;    }     */}</code></pre><p>参考：</p><p><a href="https://blog.csdn.net/yuanlaijike/article/details/80522621" target="_blank" rel="noopener">Axiso解决跨域访问</a></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用js函数</title>
      <link href="/2019/10/08/%E5%B8%B8%E7%94%A8js%E5%87%BD%E6%95%B0/"/>
      <url>/2019/10/08/%E5%B8%B8%E7%94%A8js%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>参考：</p><p><a href="https://juejin.im/post/5d1a45b0f265da1bb277494c#heading-0" target="_blank" rel="noopener">让你瞬间提高工作效率的常用js函数汇总(持续更新)</a></p><h3 id="常用的正则校验"><a href="#常用的正则校验" class="headerlink" title="常用的正则校验"></a>常用的正则校验</h3><pre><code class="javascript">// 匹配邮箱let reg = /^([a-zA-Z]|[0-9])(\w|\-)+@[a-zA-Z0-9]+\.([a-zA-Z]{2,4})$// (新)匹配手机号let reg = /^1[0-9]{10}$/;// (旧)匹配手机号let reg = /^1(3|4|5|7|8)[0-9]{9}$/;// 匹配8-16位数字和字母密码的正则表达式let reg = /^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]{8,16}$/;// 匹配国内电话号码 0510-4305211let reg = /\d{3}-\d{8}|\d{4}-\d{7}/;// 匹配身份证号码let reg=/(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)/;// 匹配腾讯QQ号let reg = /[1-9][0-9]{4,}/;// 匹配ip地址let reg = /\d+\.\d+\.\d+\.\d+/;// 匹配中文let reg = /^[\u4e00-\u9fa5]*$/;</code></pre><h3 id="常用的设备检测方式"><a href="#常用的设备检测方式" class="headerlink" title="常用的设备检测方式"></a>常用的设备检测方式</h3><pre><code class="javascript">let isWechat = /micromessenger/i.test(navigator.userAgent),    isWeibo = /weibo/i.test(navigator.userAgent),    isQQ = /qq\//i.test(navigator.userAgent),    isIOS = /(iphone|ipod|ipad|ios)/i.test(navigator.userAgent),    isAndroid = /android/i.test(navigator.userAgent);</code></pre><h3 id="常用的日期时间函数"><a href="#常用的日期时间函数" class="headerlink" title="常用的日期时间函数"></a>常用的日期时间函数</h3><pre><code class="javascript">// 时间格式化function format_date(timeStamp) {    let date = new Date(timeStamp);    return date.getFullYear() + &quot;年&quot;        + prefix_zero(date.getMonth() + 1) + &quot;月&quot;        + prefix_zero(date.getDate()) + &quot;日 &quot;        + prefix_zero(date.getHours()) + &quot;:&quot;        + prefix_zero(date.getMinutes());}// 数字格式化function prefix_zero(num) {    return num &gt;= 10 ? num : &quot;0&quot; + num;}// 倒计时时间格式化function format_time(timeStamp) {    let day = Math.floor(timeStamp / (24 * 3600 * 1000));    let leave1 = timeStamp % (24 * 3600 * 1000);    let hours = Math.floor(leave1 / (3600 * 1000));    let leave2 = leave1 % (3600 * 1000);    let minutes = Math.floor(leave2 / (60 * 1000));    let leave3 = leave2 % (60 * 1000);    let seconds = Math.floor(leave3 / 1000);    if (day) return day + &quot;天&quot; + hours + &quot;小时&quot; + minutes + &quot;分&quot;;    if (hours) return hours + &quot;小时&quot; + minutes + &quot;分&quot; + seconds + &quot;秒&quot;;    if (minutes) return minutes + &quot;分&quot; + seconds + &quot;秒&quot;;    if (seconds) return seconds + &quot;秒&quot;;    return &quot;时间到！&quot;;}</code></pre><h3 id="跨端事件处理"><a href="#跨端事件处理" class="headerlink" title="跨端事件处理"></a>跨端事件处理</h3><pre><code class="javascript">// 是否支持触摸事件let isSupportTouch = (&quot;ontouchstart&quot; in document.documentElement) ? true : false;//禁用Enter键表单自动提交document.onkeydown = function(event) {    let target, code, tag;    if (!event) {        event = window.event; //针对ie浏览器        target = event.srcElement;        code = event.keyCode;        if (code == 13) {            tag = target.tagName;            if (tag == &quot;TEXTAREA&quot;) { return true; }            else { return false; }        }    }    else {        target = event.target; //针对遵循w3c标准的浏览器，如Firefox        code = event.keyCode;        if (code == 13) {            tag = target.tagName;            if (tag == &quot;INPUT&quot;) { return false; }            else { return true; }        }    }};</code></pre><h3 id="移动端适配方案"><a href="#移动端适配方案" class="headerlink" title="移动端适配方案"></a>移动端适配方案</h3><pre><code class="javascript">(function (doc, win) {    var docEl = doc.documentElement,        resizeEvt = &#39;orientationchange&#39; in window ? &#39;orientationchange&#39; : &#39;resize&#39;,        recalc = function () {            var clientWidth = docEl.clientWidth;            var fontSize = 20;            docEl.style.fontSize = fontSize + &#39;px&#39;;            var docStyles = getComputedStyle(docEl);            var realFontSize = parseFloat(docStyles.fontSize);            var scale = realFontSize / fontSize;            console.log(&quot;realFontSize: &quot; + realFontSize + &quot;, scale: &quot; + scale);            fontSize = clientWidth / 667 * 20;            if(isIphoneX()) fontSize = 19;            fontSize = fontSize / scale;            docEl.style.fontSize = fontSize + &#39;px&#39;;        };    // Abort if browser does not support addEventListener    if (!doc.addEventListener) return;    win.addEventListener(resizeEvt, recalc, false);    doc.addEventListener(&#39;DOMContentLoaded&#39;, recalc, false);    // iphoneX判断    function isIphoneX(){        return /iphone/gi.test(navigator.userAgent) &amp;&amp; (screen.height == 812 &amp;&amp; screen.width == 375)    }})(document, window);</code></pre><h3 id="xss预防方式"><a href="#xss预防方式" class="headerlink" title="xss预防方式"></a>xss预防方式</h3><pre><code class="javascript">// 敏感符号转义function entities(s) {    let e = {        &#39;&quot;&#39;: &#39;&amp;quot;&#39;,        &#39;&amp;&#39;: &#39;&amp;amp;&#39;,        &#39;&lt;&#39;: &#39;&amp;lt;&#39;,        &#39;&gt;&#39;: &#39;&amp;gt;&#39;    }    return s.replace(/[&quot;&lt;&gt;&amp;]/g, m =&gt; {        return e[m]    })}</code></pre><h3 id="常用的js算法"><a href="#常用的js算法" class="headerlink" title="常用的js算法"></a>常用的js算法</h3><pre><code class="javascript">/** * 节流函数--规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。 */function throttle(fun, delay) {    let last, deferTimer    return function (args) {        let that = this        let _args = arguments        let now = +new Date()        if (last &amp;&amp; now &lt; last + delay) {            clearTimeout(deferTimer)            deferTimer = setTimeout(function () {                last = now                fun.apply(that, _args)            }, delay)        }else {            last = now            fun.apply(that,_args)        }    }}/** * 防抖函数--在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时 */ function debounce(fun, delay) {    return function (args) {        let that = this        clearTimeout(fun.id)        fun.id = setTimeout(function () {            fun.call(that, args)        }, delay)    }}// 观察者模式let Observer = (function(){  let t __messages = {};  return {    regist: function(type, fn) {      if(typeof __messages[type] === &#39;undefined&#39;) {        messages[type] = [fn];      }else {        __messages[type].push(fn);      }    },    fire: function(type, args) {      if(!__messages[type]){        return      }      let events = {        type: type,        args: args || {}      },      i = 0,      len = __messages[type].length;      for(;i&lt;len;i++){        __messages[type][i].call(this, events);      }    },    remove: function(type, fn) {      if(__messages[type] instanceof Array){        let i = __messages[type].length -1;        for(;i&gt;=0;i--){          __messages[type][i] === fn &amp;&amp; __messages[type].splice(i, 1)        }      }    }  }})(); // 模板渲染方法 function formatString(str, data) {   return str.replace(/\{\{(\w+)\}\}/g, function(match, key) {     return typeof data[key] === undefined ? &#39;&#39; : data[key]   }) } // 冒泡排序function bubbleSort(arr) {    for (let i = arr.length - 1; i &gt; 0; i--) {      for (let j = 0; j &lt; i; j++) {        if (arr[j] &gt; arr[j + 1]) {          swap(arr, j, j + 1);        }      }    }    return arr;}// 置换函数function swap(arr, indexA, indexB) {    [arr[indexA], arr[indexB]] = [arr[indexB], arr[indexA]];}// 数组去重function distinct(arr = testArr) {    return arr.filter((v, i, array) =&gt; array.indexOf(v) === i)}</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题</title>
      <link href="/2019/10/08/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/10/08/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="Shadow-DOM和Virtual-DOM有什么区别？"><a href="#Shadow-DOM和Virtual-DOM有什么区别？" class="headerlink" title="Shadow DOM和Virtual DOM有什么区别？"></a>Shadow DOM和Virtual DOM有什么区别？</h3><ul><li>Shadow DOM 是Web Components标准，为Web组件提供了封装，Shadow DOM使得这些东西与主文档的DOM保持分离</li><li>Virtual DOM 是 Rect/Vue等框架实现的虚拟DOM，其本质上是JavaScript对象，用于模拟DOM对象，在需要操作DOM的地方，先操作Virtual DOM，在render到真实DOM上，以达到更好的性能</li></ul><h3 id="meta的属性有哪些组成？说说它们的分别有什么作用？"><a href="#meta的属性有哪些组成？说说它们的分别有什么作用？" class="headerlink" title="meta的属性有哪些组成？说说它们的分别有什么作用？"></a>meta的属性有哪些组成？说说它们的分别有什么作用？</h3><p><strong>charset</strong><br>此特性声明当前文档所使用的字符编码，但该声明可以被任何一个元素的 lang 特性的值覆盖。</p><p><strong>http-equiv</strong></p><ul><li>content-language 指定页面使用的默认语言</li><li>content-security-policy 它允许页面作者定义当前页的 内容策略。 内容策略主要指定允许的服务器源和脚本端点，这有助于防止跨站点脚本攻击。</li><li>default-style 这个属性指定了在页面上使用的首选样式表.</li></ul><p><strong>name</strong></p><ul><li>author 就是这个文档的作者名称，可以用自由的格式去定义。</li><li>description 其中包含页面内容的简短和精确的描述。 一些浏览器，如Firefox和Opera，将其用作书签页面的默认描述。</li><li>generator 包含生成页面的软件的标识符。</li><li>keywords 包含与逗号分隔的页面内容相关的单词。</li><li>referrer 控制所有从该文档发出的 HTTP 请求中HTTP Referer 首部的内容。</li></ul><h3 id="移动端的性能优化有哪些方法？"><a href="#移动端的性能优化有哪些方法？" class="headerlink" title="移动端的性能优化有哪些方法？"></a>移动端的性能优化有哪些方法？</h3><ul><li>首屏加载和按需加载，非首屏内容滚屏加载，保证首屏内容最小化</li><li>模块化资源并行下载</li><li>inline 首屏必备的 CSS 和 JavaScript</li><li>meta dns prefetch 设置 DNS 预解析</li></ul><pre><code>&lt;!--cdn域名预解析--&gt;&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; &gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//cdn.domain.com&quot; &gt;</code></pre><ul><li>资源预加载:对于移动端首屏加载后可能会被使用的资源，需要在首屏完成加载后尽快进行加载，保证在用户需要浏览时已经加载完成</li><li>尝试使用 PWA 模式</li><li>图片压缩处理</li><li>使用较小的图片，合理使用 base64 内嵌图片</li><li>使用更高压缩比格式的图片：webp格式</li><li>图片懒加载</li><li>使用 iconfont 代替图片图标</li></ul><h3 id="你有使用过HTML5的output吗？说说它的作用是什么？"><a href="#你有使用过HTML5的output吗？说说它的作用是什么？" class="headerlink" title="你有使用过HTML5的output吗？说说它的作用是什么？"></a>你有使用过HTML5的output吗？说说它的作用是什么？</h3><p>兼容性：Internet Explorer 8 以及更早的版本不支持 标签。<br>属性：for form name<br>用法：与input标签，form标签联合使用<br>作用：在form监听oninput事件绑定关联的input值计算方法，输出计算结果。</p><ul><li>定义表单输出</li><li>它有以下属性<ul><li>for: <element_id> 定义输出域相关的一个或多个元素</li><li>form: <form_id> 定义输入字段所属的一个或多个表单</li><li>name: 定义对象的唯一名称。（表单提交时使用）</li></ul></li><li>Demo</li></ul><pre><code class="html">&lt;form id=&quot;form&quot; oninput=&quot;x.value=parseInt(a.value)+parseInt(b.value)&quot;&gt;    0&lt;input type=&quot;range&quot; id=&quot;a&quot; value=&quot;50&quot;&gt;100    +&lt;input type=&quot;number&quot; id=&quot;b&quot; value=&quot;50&quot;&gt;&lt;/form&gt;=&lt;output form=&quot;form&quot; name=&quot;x&quot; for=&quot;a b&quot;&gt;&lt;/output&gt;</code></pre><h3 id="有些js库习惯在代码开头处添加分号有什么作用呢？除了分号还可以换成别的吗？"><a href="#有些js库习惯在代码开头处添加分号有什么作用呢？除了分号还可以换成别的吗？" class="headerlink" title="有些js库习惯在代码开头处添加分号有什么作用呢？除了分号还可以换成别的吗？"></a>有些js库习惯在代码开头处添加分号有什么作用呢？除了分号还可以换成别的吗？</h3><ul><li>作用：防止压缩后，当前一个js文件末尾没有分号时，浏览器会把它们当成一条语句处理，引起错误</li><li>可以用<code>void</code> <code>!</code> <code>+</code> <code>~</code> 代替</li></ul><h3 id="举例说明js拖拽用到的事件有哪些？"><a href="#举例说明js拖拽用到的事件有哪些？" class="headerlink" title="举例说明js拖拽用到的事件有哪些？"></a>举例说明js拖拽用到的事件有哪些？</h3><ul><li><p>传统方式</p><ul><li>PC：<code>mousedonw``mousemove``mouseup</code></li><li>移动端：<code>touchstart``touchmove``touchend</code></li><li>原理：通过计算坐标的方式来实现元素的可视化移动。</li></ul></li><li><p>HTML5原生拖拽</p><ul><li><code>dragstart``drag``dragenter``dragover``dragleave``drop``dragend</code></li><li>原理：通过对被拖动元素和拖动目标元素进行事件监听，实现拖动效果</li></ul></li><li><p>区别</p><ul><li>传统方式是实现元素的实时移动，HTML5原生拖拽事件是体现元素的拖拽结果，需要确定拖拽的目标区域，如应用于拖拽上传。</li></ul></li><li><p>demo</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;        &lt;title&gt;Document&lt;/title&gt;        &lt;style&gt;            * {                margin: 0;                padding: 0;            }            .tra {                width: 70px;                height: 70px;                position: fixed;                background: red;            }            .drag {                width: 80px;                height: 80px;                background: blueviolet;            }            #dragTarget {                width: 200px;                height: 200px;                border: 1px solid;            }        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!-- HTML Draggable --&gt;        &lt;div class=&quot;drag&quot; id=&quot;drag&quot; draggable=&quot;true&quot;&gt;&lt;/div&gt;        &lt;div id=&quot;dragTarget&quot;&gt;&lt;/div&gt;        &lt;!-- 传统的拖拽 --&gt;        &lt;div id=&quot;tra&quot; class=&quot;tra&quot;&gt;        &lt;/div&gt;</code></pre></li></ul><pre><code>      &lt;script&gt;          // 传统的拖拽          ; (function () {              var tra = document.querySelector(&#39;#tra&#39;);              var startPoint = Object.create(null);              var isStartMove = false;              const addUnit = num =&gt; num + &#39;px&#39;;              tra.addEventListener(&#39;mousedown&#39;, e =&gt; {                  isStartMove = true;                  startPoint = {                      x: e.offsetX,                      y: e.offsetY,                  }              });              window.addEventListener(&#39;mousemove&#39;, e =&gt; {                  if (!isStartMove) return;                  tra.style.left = addUnit(e.clientX - startPoint.x);                  tra.style.top = addUnit(e.clientY - startPoint.y);              });              window.addEventListener(&#39;mouseup&#39;, e =&gt; {                  isStartMove = false;                  startPoint = {                      x: 0,                      y: 0,                  }              });          })();          // HTML5拖拽事件          ;(function() {              var dragEl = document.querySelector(&#39;#drag&#39;);              dragEl.addEventListener(&#39;dragstart&#39;, e =&gt; {                  e.dataTransfer.setData(&quot;Text&quot;,e.target.id);                  e.dataTransfer.effectAllowed = &#39;copyMove&#39;;              });              var dragTargetEl = document.querySelector(&#39;#dragTarget&#39;);              dragTargetEl.addEventListener(&#39;dragenter&#39;, e =&gt; {                  e.preventDefault();              });              dragTargetEl.addEventListener(&#39;dragover&#39;, e =&gt; {                  e.preventDefault();              });              dragTargetEl.addEventListener(&#39;drop&#39;, e =&gt; {                  e.preventDefault();                  var id = e.dataTransfer.getData(&#39;Text&#39;);                  e.target.appendChild(document.getElementById(id));              })          })();      &lt;/script&gt;  &lt;/body&gt;</code></pre>  </html>  ```<h3 id="css中的border-none和border-0px有什么区别？"><a href="#css中的border-none和border-0px有什么区别？" class="headerlink" title="css中的border:none和border:0px有什么区别？"></a>css中的border:none和border:0px有什么区别？</h3><p>在于浏览器解析与否</p><ol><li>border为0的情况下虽然看不见,但是浏览器会对border进行渲染,还是占据内存的<br>而border为none时浏览器不会对其渲染,所以不会占据内存</li><li>border为none的兼容差 在老IE浏览器上还是会有边框<br>而border为0的时候是可以隐藏的</li></ol><h3 id="举例说明如何在页面中添加数学公式？"><a href="#举例说明如何在页面中添加数学公式？" class="headerlink" title="举例说明如何在页面中添加数学公式？"></a>举例说明如何在页面中添加数学公式？</h3><p><a href="http://jartto.wang/2018/07/08/perfect-math/" target="_blank" rel="noopener">http://jartto.wang/2018/07/08/perfect-math/</a></p><h3 id="请说说在什么时候用transition？什么时候使用animation？"><a href="#请说说在什么时候用transition？什么时候使用animation？" class="headerlink" title="请说说在什么时候用transition？什么时候使用animation？"></a>请说说在什么时候用transition？什么时候使用animation？</h3><ul><li><code>transition</code> 相当于是个过度动画，需要又过度效果才会触发。一般用来做元素的放大缩小、平移旋转等简单的操作。<code>transition</code> 只执行一次，当需要执行多次时，一般会利用 <code>:hover</code> 等时机或者使用 <code>javaScript</code> 改变类名进行控制。</li><li><code>animation</code> 需要自己设定关键帧，可以做相对复杂的操作，比如延迟、循环播放等。一般在需要比较复杂的情况才会使用 <code>animation</code>。</li></ul><h3 id="针对jQuery性能的优化方法有哪些？"><a href="#针对jQuery性能的优化方法有哪些？" class="headerlink" title="针对jQuery性能的优化方法有哪些？"></a>针对jQuery性能的优化方法有哪些？</h3><ul><li>show slide animate 等频繁修改 dom 很耗性能，可采用  <a href="http://code.ciaoca.com/jquery/transit/" target="_blank" rel="noopener">jquery.transit 插件</a> 等</li><li>使用单个 id 或 class 选择器当然也是优化点咯，元素选择器是真的会卡</li><li>每次调用 $() 其实都是生成一个超大的对象，还是尽量存为变量吧</li><li>用 jquery 写事件委托是最爽的，优点也是非常明显的</li></ul><h3 id="怎样把整个页面中的内容设置成只读-不可编辑的状态"><a href="#怎样把整个页面中的内容设置成只读-不可编辑的状态" class="headerlink" title="怎样把整个页面中的内容设置成只读,不可编辑的状态?"></a>怎样把整个页面中的内容设置成只读,不可编辑的状态?</h3><pre><code class="html">方法1: οnfοcus=this.blur() &lt;input type=&quot;text&quot; name=&quot;input1&quot; value=&quot;中国&quot; οnfοcus=this.blur()&gt; 方法2:readonly &lt;input type=&quot;text&quot; name=&quot;input1&quot; value=&quot;中国&quot; readonly&gt; &lt;input type=&quot;text&quot; name=&quot;input1&quot; value=&quot;中国&quot; readonly=&quot;true&quot;&gt; 方法3: disabled &lt;input type=&quot;text&quot; name=&quot;input1&quot; value=&quot;中国&quot; disabled&gt;</code></pre><h3 id="怎样对css文件进行压缩合并的？"><a href="#怎样对css文件进行压缩合并的？" class="headerlink" title="怎样对css文件进行压缩合并的？"></a>怎样对css文件进行压缩合并的？</h3><ul><li>使用在线网站进行压缩，如<a href="http://tool.lu/css" target="_blank" rel="noopener">http://tool.lu/css</a></li><li>如使用Gulp，可使用<code>gulp-minify-css</code>进行压缩</li><li>如使用WebPack，可使用<code>optimize-css-assets-webpack-plugin</code>进行压缩</li></ul>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>断点续传</title>
      <link href="/2019/10/08/%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0/"/>
      <url>/2019/10/08/%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<!-- # 断点续传 --><p>主要依赖http协议的206返回码。前提条件是通信双方使用http1.1以上协议。</p><p>客户端使用请求头Range告知自己需要的数据范围；服务器使用响应头Content-Range说明返回的数据范围和数据长度。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>meta属性</title>
      <link href="/2019/10/08/meta%E5%B1%9E%E6%80%A7/"/>
      <url>/2019/10/08/meta%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<!-- # meta属性 --><pre><code class="html">&lt;!DOCTYPE html&gt; &lt;!-- 使用 HTML5 doctype，不区分大小写 --&gt;&lt;html lang=&quot;zh-cmn-Hans&quot;&gt; &lt;!-- 更加标准的 lang 属性写法 http://zhi.hu/XyIa --&gt;&lt;head&gt;    &lt;!-- 声明文档使用的字符编码 --&gt;    &lt;meta charset=&#39;utf-8&#39;&gt;    &lt;!-- 优先使用 IE 最新版本和 Chrome --&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt;    &lt;!-- 页面描述 --&gt;    &lt;meta name=&quot;description&quot; content=&quot;不超过150个字符&quot;/&gt;    &lt;!-- 页面关键词 --&gt;    &lt;meta name=&quot;keywords&quot; content=&quot;&quot;/&gt;    &lt;!-- 网页作者 --&gt;    &lt;meta name=&quot;author&quot; content=&quot;name, email@gmail.com&quot;/&gt;    &lt;!-- 搜索引擎抓取 --&gt;    &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt;    &lt;!-- 为移动设备添加 viewport --&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;    &lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 http://bigc.at/ios-webapp-viewport-meta.orz --&gt;    &lt;!-- iOS 设备 begin --&gt;    &lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt;    &lt;!-- 添加到主屏后的标题（iOS 6 新增） --&gt;    &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;/&gt;    &lt;!-- 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 --&gt;    &lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL&quot;&gt;    &lt;!-- 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari） --&gt;    &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;/&gt;    &lt;!-- 设置苹果工具栏颜色 --&gt;    &lt;meta name=&quot;format-detection&quot; content=&quot;telphone=no, email=no&quot;/&gt;    &lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt;    &lt;!-- 启用360浏览器的极速模式(webkit) --&gt;    &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;    &lt;!-- 避免IE使用兼容模式 --&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;!-- 不让百度转码 --&gt;    &lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt;    &lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;    &lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;    &lt;!-- 微软的老式浏览器 --&gt;    &lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;    &lt;!-- uc强制竖屏 --&gt;    &lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;    &lt;!-- QQ强制竖屏 --&gt;    &lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;    &lt;!-- UC强制全屏 --&gt;    &lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;    &lt;!-- QQ强制全屏 --&gt;    &lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;    &lt;!-- UC应用模式 --&gt;    &lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;    &lt;!-- QQ应用模式 --&gt;    &lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;    &lt;!-- windows phone 点击无高光 --&gt;    &lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;    &lt;!-- iOS 图标 begin --&gt;    &lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;/apple-touch-icon-57x57-precomposed.png&quot;/&gt;    &lt;!-- iPhone 和 iTouch，默认 57x57 像素，必须有 --&gt;    &lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;114x114&quot; href=&quot;/apple-touch-icon-114x114-precomposed.png&quot;/&gt;    &lt;!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 --&gt;    &lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;144x144&quot; href=&quot;/apple-touch-icon-144x144-precomposed.png&quot;/&gt;    &lt;!-- Retina iPad，144x144 像素，可以没有，但推荐有 --&gt;    &lt;!-- iOS 图标 end --&gt;    &lt;!-- iOS 启动画面 begin --&gt;    &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;768x1004&quot; href=&quot;/splash-screen-768x1004.png&quot;/&gt;    &lt;!-- iPad 竖屏 768 x 1004（标准分辨率） --&gt;    &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1536x2008&quot; href=&quot;/splash-screen-1536x2008.png&quot;/&gt;    &lt;!-- iPad 竖屏 1536x2008（Retina） --&gt;    &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1024x748&quot; href=&quot;/Default-Portrait-1024x748.png&quot;/&gt;    &lt;!-- iPad 横屏 1024x748（标准分辨率） --&gt;    &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;2048x1496&quot; href=&quot;/splash-screen-2048x1496.png&quot;/&gt;    &lt;!-- iPad 横屏 2048x1496（Retina） --&gt;    &lt;link rel=&quot;apple-touch-startup-image&quot; href=&quot;/splash-screen-320x480.png&quot;/&gt;    &lt;!-- iPhone/iPod Touch 竖屏 320x480 (标准分辨率) --&gt;    &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;640x960&quot; href=&quot;/splash-screen-640x960.png&quot;/&gt;    &lt;!-- iPhone/iPod Touch 竖屏 640x960 (Retina) --&gt;    &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;640x1136&quot; href=&quot;/splash-screen-640x1136.png&quot;/&gt;    &lt;!-- iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina) --&gt;    &lt;!-- iOS 启动画面 end --&gt;    &lt;!-- iOS 设备 end --&gt;    &lt;meta name=&quot;msapplication-TileColor&quot; content=&quot;#000&quot;/&gt;    &lt;!-- Windows 8 磁贴颜色 --&gt;    &lt;meta name=&quot;msapplication-TileImage&quot; content=&quot;icon.png&quot;/&gt;    &lt;!-- Windows 8 磁贴图标 --&gt;    &lt;link rel=&quot;alternate&quot; type=&quot;application/rss+xml&quot; title=&quot;RSS&quot; href=&quot;/rss.xml&quot;/&gt;    &lt;!-- 添加 RSS 订阅 --&gt;    &lt;link rel=&quot;shortcut icon&quot; type=&quot;image/ico&quot; href=&quot;/favicon.ico&quot;/&gt;    &lt;!-- 添加 favicon icon --&gt;    &lt;!-- sns 社交标签 begin --&gt;    &lt;!-- 参考微博API --&gt;    &lt;meta property=&quot;og:type&quot; content=&quot;类型&quot; /&gt;    &lt;meta property=&quot;og:url&quot; content=&quot;URL地址&quot; /&gt;    &lt;meta property=&quot;og:title&quot; content=&quot;标题&quot; /&gt;    &lt;meta property=&quot;og:image&quot; content=&quot;图片&quot; /&gt;    &lt;meta property=&quot;og:description&quot; content=&quot;描述&quot; /&gt;    &lt;!-- sns 社交标签 end --&gt;    &lt;title&gt;标题&lt;/title&gt;&lt;/head&gt;</code></pre><p>meta是html语言head区的一个辅助性标签。也许你认为这些代码可有可无。其实如果你能够用好meta标签，会给你带来意想不到的效果，meta标签的作用有：搜索引擎优化（<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fcaibaojian.com%2Ft%2Fseo" target="_blank" rel="noopener">seo</a>），定义页面使用语言，自动刷新并指向新的页面，实现网页转换时的动态效果，控制页面缓冲，网页定级评价，控制网页显示的窗口等！</p><p>meta标签的组成：meta标签共有两个属性，它们分别是http-equiv属性和name属性，不同的属性又有不同的参数值，这些不同的参数值就实现了不同的网页功能。</p><p><strong>charset</strong><br>此特性声明当前文档所使用的字符编码，但该声明可以被任何一个元素的 lang 特性的值覆盖。</p><p><strong>http-equiv</strong></p><ul><li>content-language 指定页面使用的默认语言</li><li>content-security-policy 它允许页面作者定义当前页的 内容策略。 内容策略主要指定允许的服务器源和脚本端点，这有助于防止跨站点脚本攻击。</li><li>default-style 这个属性指定了在页面上使用的首选样式表.</li></ul><p><strong>name</strong></p><ul><li>author 就是这个文档的作者名称，可以用自由的格式去定义。</li><li>description 其中包含页面内容的简短和精确的描述。 一些浏览器，如Firefox和Opera，将其用作书签页面的默认描述。</li><li>generator 包含生成页面的软件的标识符。</li><li>keywords 包含与逗号分隔的页面内容相关的单词。</li><li>referrer 控制所有从该文档发出的 HTTP 请求中HTTP Referer 首部的内容。</li></ul><p>参考：</p><p><a href="https://www.jianshu.com/p/04a4021b2a44" target="_blank" rel="noopener">meta属性整理</a></p><ul><li><p>基本概念</p><ul><li>content属性是必要的，还有3个非必要属性:http-equiv/name/scheme(不常用)</li></ul></li><li><p>添加服务器发送到浏览器的http头部内容</p><pre><code class="html">&lt;!-- 浏览器的头部就会包括这些: charset:iso-8859-1 expires:31 Dec 2008 --&gt;&lt;meta http-equiv=&quot;charset&quot; content=&quot;iso-8859-1&quot;&gt;&lt;meta http-equiv=&quot;expires&quot; content=&quot;31 Dec 2008&quot;&gt;&lt;!-- 5s后重定向到Google --&gt;&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;5;url=https://www.google.com&quot; /&gt;</code></pre></li><li><p>解析方式定义</p><pre><code class="html">&lt;!-- 用webkit内核进行解析 --&gt;&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;* 常用的meta标签&lt;!-- 声明文档使用的字符编码，一定要写第一行(有以下两种写法) --&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;!-- 禁止百度转码 --&gt;&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt;&lt;!-- SEO优化部分 --&gt;&lt;!-- 页面标题&lt;title&gt;标签(head 头部必须) --&gt;&lt;title&gt;your title&lt;/title&gt;&lt;!-- 页面关键词 keywords --&gt;&lt;meta name=&quot;keywords&quot; content=&quot;your keywords&quot;&gt;&lt;!-- 页面描述内容 description --&gt;&lt;meta name=&quot;description&quot; content=&quot;your description&quot;&gt;&lt;!-- 定义网页作者 author --&gt;&lt;meta name=&quot;author&quot; content=&quot;author,email address&quot;&gt;&lt;!-- 定义网页搜索引擎索引方式，robotterms 是一组使用英文逗号「,」分割的值，通常有如下几种取值：none，noindex，nofollow，all，index和follow。 --&gt;&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;&gt;&lt;!-- viewport主要是影响移动端页面布局的 --&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;- content 参数：    - width viewport 宽度(数值/device-width)    - height viewport 高度(数值/device-height)    - initial-scale 初始缩放比例    - maximum-scale 最大缩放比例    - minimum-scale 最小缩放比例    - user-scalable 是否允许用户缩放(yes/no)&lt;!-- 移动端常用 --&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no&quot; /&gt;&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt;&lt;meta name=&quot;format-detection&quot;content=&quot;telephone=no, email=no&quot; /&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no&quot; /&gt;&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;&lt;!-- 删除苹果默认的工具栏和菜单栏 --&gt;&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt;&lt;!-- 设置苹果工具栏颜色 --&gt;&lt;meta name=&quot;format-detection&quot; content=&quot;telphone=no, email=no&quot; /&gt;&lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt;&lt;!-- 启用360浏览器的极速模式(webkit) --&gt;&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;&lt;!-- 避免IE使用兼容模式 --&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;&lt;!-- 微软的老式浏览器 --&gt;&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;&lt;!-- uc强制竖屏 --&gt;&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- QQ强制竖屏 --&gt;&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- UC强制全屏 --&gt;&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;&lt;!-- QQ强制全屏 --&gt;&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;&lt;!-- UC应用模式 --&gt;&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;&lt;!-- QQ应用模式 --&gt;&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;&lt;!-- windows phone 点击无高光 --&gt;&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;&lt;!-- 适应移动端end --&gt;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>currentColor</title>
      <link href="/2019/10/08/currentColor/"/>
      <url>/2019/10/08/currentColor/</url>
      
        <content type="html"><![CDATA[<!-- # currentColor --><p>概念： 当前文字颜色</p><p>应用场景： <code>background-color</code> | <code>border-color</code> | <code>gradient</code> | <code>box-shadow</code></p><p>参考：</p><p><a href="https://www.zhangxinxu.com/wordpress/2014/10/currentcolor-css3-powerful-css-keyword/" target="_blank" rel="noopener">currentColor-CSS3超高校级好用CSS变量</a></p><blockquote><p><code>border</code> 和 <code>box-shadow</code> 默认的颜色就是当前的文字颜色，也就是类似 <code>currentColor</code> ；</p><p>其次，在IOS Safari浏览器（IOS8）下， <code>currentColor</code> 有一些bug的，例如伪元素hover时候， <code>background:currentColor</code>  的背景色不会跟着变化。可以使用 <code>border</code> 来模拟。</p></blockquote><p>图标链接的实现方法：</p><p>button + svg 实现，语义好，兼容性差。</p><p>a + i 实现，a 标签具有键盘可访问性，同时兼容性好（尺寸控制上）， 同时设置 <code>role=&quot;button&quot;</code> 具有按钮语义。i 标签用在装饰图形上。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>readonly与disabled区别</title>
      <link href="/2019/10/08/readonly%E5%92%8Cdisabled%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/10/08/readonly%E5%92%8Cdisabled%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<!-- # readonly与disabled区别 --><p><code>readonly</code> 和 <code>disabled</code> 它们都能够做到使用户不能够更改表单域中的内容。但是它们之间有着微小的差别，总结如下：</p><p> Readonly只针对input(text / password)和textarea有效，而disabled对于所有的表单元素都有效，但是表单元素在使用了disabled后，当我们将表单以POST或GET的方式提交的话，这个元素的值不会被传递出去，而readonly会将该值传递出去（readonly接受值更改可以回传，disable接受改但不回传数据）。</p><p>一般比较常用的情况是：<br>在某个表单中为用户预填了某个唯一识别代码，不允许用户改动，但是在提交时需要传递该值，此时应该将它的属性设置为readonly 。</p><p>经常遇到当用户正式提交了表单后需要等待管理员的信息验证，这就不允许用户再更改表单中的数据，而是只能够查看，由于disabled的作用元素范围大，所以此时应该使用disabled，但同时应该注意的是要将submit button也disabled掉，否则只要用户按了这个按钮，如果在数据库操作页面中没有做完整性检测的话，数据库中的值就会被清除。如果说在这种情况下用readonly来代替disabled的话，若表单中只有input(text / password)和textarea元素，那还是可以的，如果存在其他发元素，比如select，用户可以在重新改写值后按回车键进行提交(回车是默认的submit触发按键)</p><p>我们常常在用户按了提交按钮后，利用javascript将提交按钮disabled掉，这样可以防止网络条件比较差的环境下，用户反复点提交按钮导致数据冗余地存入数据库。</p><p>disabled和readonly这两个属性有一些共同之处，比如都设为true，则form属性将不能被编辑，往往在写js代码的时候容易混合使用这两个属性，其实他们之间是有一定区别的：</p><ul><li><p>如果一个输入项的disabled设为true，则该表单输入项不能获取焦点，用户的所有操作（鼠标点击和键盘输入等）对该输入项都无效，最重要的一点是当提交表单时，这个表单输入项将不会被提交。</p></li><li><p>而readonly只是针对文本输入框这类可以输入文本的输入项，如果设为true，用户只是不能编辑对应的文本，但是仍然可以聚焦焦点，并且在提交表单的时候，该输入项会作为form的一项提交。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端性能优化gzip</title>
      <link href="/2019/10/08/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96gzip/"/>
      <url>/2019/10/08/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96gzip/</url>
      
        <content type="html"><![CDATA[<!-- # 前端性能优化gzip --><h3 id="什么是gzip"><a href="#什么是gzip" class="headerlink" title="什么是gzip"></a>什么是gzip</h3><p>gzip就是GNUzip的缩写，也是一个文件压缩程序，可以将文件压缩进后缀为.gz的压缩包。而我们前端所讲的gzip压缩优化，就是通过gzip这个压缩程序，对资源进行压缩，从而降低请求资源的文件大小。</p><p>gzip压缩优化在业界的应用有多么普遍呢，基本上你打开任何一个网站，看它们的html，js，css文件都是经过gzip压缩的（即使js，css这类文件经过了混淆压缩之后，gzip仍然可以明显的优化文件体积。）。</p><blockquote><p>Tips：通常gzip对纯文本内容可压缩到原大小的40%。但png、gif、jpg、jpeg这类图片文件并不推荐使用gzip压缩（svg是个例外），首先经过压缩后的图片文件gzip能压缩的空间很小。事实上，添加标头，压缩字典，并校验响应体可能会让它更大。</p></blockquote><p>比如访问掘金，打开调试工具，在网络请求Network中，选择一个js或css，都能在Response Headers中找到 <strong>content-encoding: gzip</strong> 键值对，这就表示了这个文件是启用了gzip压缩的。</p><h3 id="gzip压缩过程"><a href="#gzip压缩过程" class="headerlink" title="gzip压缩过程"></a>gzip压缩过程</h3><p>此处我们用原生node写一个服务：</p><pre><code class="javascript">const http = require(&quot;http&quot;);const fs = require(&quot;fs&quot;);const server = http.createServer((req, res) =&gt; {  const rs = fs.createReadStream(`static${req.url}`); //读取文件流  rs.pipe(res); //将数据以流的形式返回  rs.on(&quot;error&quot;, err =&gt; {    //找不到返回404    console.log(err);    res.writeHead(404);    res.write(&quot;Not Found&quot;);  });});//监听8080server.listen(8080, () =&gt; {  console.log(&quot;listen prot:8080&quot;);});</code></pre><p>用<code>node server.js</code>启动服务，此时我们访问 <a href="http://localhost:8080/xxx.js，网页会显示xxx.js文件的内容，查看Network面版，会发现xxx.js请求大小是88.73k，和原始资源文件大小一致，Response" target="_blank" rel="noopener">http://localhost:8080/xxx.js，网页会显示xxx.js文件的内容，查看Network面版，会发现xxx.js请求大小是88.73k，和原始资源文件大小一致，Response</a> Headers中也没有 <strong>content-encoding: gzip</strong> ，说明这是未经过gzip压缩的。</p><p>如何开启gzip呢，很简单，node为我们提供了zlib模块，直接使用就行，上面的代码简单修改一下就可以。</p><pre><code class="javascript">const http = require(&quot;http&quot;);const fs = require(&quot;fs&quot;);const zlib = require(&quot;zlib&quot;); // &lt;-- 引入zlib块const server = http.createServer((req, res) =&gt; {  const rs = fs.createReadStream(`static${req.url}`);  const gz = zlib.createGzip(); // &lt;-- 创建gzip压缩  rs.pipe(gz).pipe(res); // &lt;-- 返回数据前经过gzip压缩  rs.on(&quot;error&quot;, err =&gt; {    console.log(err);    res.writeHead(404);    res.write(&quot;Not Found&quot;);  });});server.listen(8080, () =&gt; {  console.log(&quot;listen prot:8080&quot;);});</code></pre><p>但是如果你尝试用编辑器打开这个文件，会发现打开失败或者提示这是一个二进制文件而不是文本。这个时候如果反应快的朋友可能会和我第一次的想法一样，试试把js后缀改成gz。因为前面说了，其实gzip就是一个压缩程序，将文件压缩进一个.gz压缩包。</p><p>原来gzip就是将资源文件压缩进一个压缩包,服务端返回压缩包的时候告诉浏览器一声，这其实是一个gz压缩包，浏览器你使用前先解压一下。而这个通知就是我们之前判断是否开启gzip压缩的请求头字段，Response Headers里的 <strong>content-encoding: gzip</strong>。</p><pre><code class="javascript">const http = require(&quot;http&quot;);const fs = require(&quot;fs&quot;);const zlib = require(&quot;zlib&quot;); const server = http.createServer((req, res) =&gt; {  const rs = fs.createReadStream(`static${req.url}`);  const gz = zlib.createGzip();   res.setHeader(&quot;content-encoding&quot;, &quot;gzip&quot;); //添加content-encoding: gzip请求头。  rs.pipe(gz).pipe(res);   rs.on(&quot;error&quot;, err =&gt; {    console.log(err);    res.writeHead(404);    res.write(&quot;Not Found&quot;);  });});server.listen(8080, () =&gt; {  console.log(&quot;listen prot:8080&quot;);</code></pre><p>此时浏览器再请求到gzip压缩后的文件，会先解压处理一下再使用。</p><h3 id="gzip的注意点"><a href="#gzip的注意点" class="headerlink" title="gzip的注意点"></a>gzip的注意点</h3><p>前面说的哪些文件适合开启gzip压缩，哪些不适合是一个注意点。</p><p>还有一个注意点是，谁来做这个gzip压缩，我们的例子是在接到请求时，由node服务器进行压缩处理。这和express中使用compression中间件，koa中使用koa-compress中间件，nginx和tomcat进行配置都是一样的，这也是比较普遍的一种做法，由服务端进行压缩处理。</p><p>服务器了解到我们这边有一个 gzip 压缩的需求，它会启动自己的 CPU 去为我们完成这个任务。而压缩文件这个过程本身是需要耗费时间的，大家可以理解为我们以服务器压缩的时间开销和 CPU 开销（以及浏览器解析压缩文件的开销）为代价，省下了一些传输过程中的时间开销。</p><p>如果我们在构建的时候，直接将资源文件打包成gz压缩包，其实也是可以的，这样可以省去服务器压缩的时间，减少一些服务端的消耗。</p><p>比如我们在使用webpack打包工具的时候可以使用<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fcompression-webpack-plugin">compression-webpack-plugin</a>插件，在构建项目的时候进行gzip打包，详细的配置使用可以去看插件的文档，非常简单。</p><p>参考：</p><p><a href="https://juejin.im/post/5d27dd2de51d454f6f16ec89#heading-4" target="_blank" rel="noopener">初探gzip</a></p><p><a href="https://blog.csdn.net/jison_r_wang/article/list/2?t=1" target="_blank" rel="noopener">gzip原理</a></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的函数方法</title>
      <link href="/2019/09/27/%E5%B0%81%E8%A3%85%E7%9A%84%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95/"/>
      <url>/2019/09/27/%E5%B0%81%E8%A3%85%E7%9A%84%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<!-- ## 常用的函数方法 --><ul><li><p>原生封装的ajax函数</p><pre><code class="javascript">function Ajax(type, url, data, success, failed){    // 创建ajax对象    var xhr = null;    if ( window.XMLHttpRequest ) {//非IE浏览器        xhr = new XMLHttpRequest();    } else {//IE浏览器        xhr = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;)    }     // 用于清除缓存    var random = Math.random();    if ( typeof data == &#39;object&#39; ) {        var str = &#39;&#39;;        for(var key in data){            str += key+&#39;=&#39;+data[key]+&#39;&amp;&#39;;        }        data = str.replace(/&amp;$/, &#39;&#39;);    }    if ( type.toUpperCase() == &#39;GET&#39; ) {        if( data ) {            xhr.open(&#39;GET&#39;, url + &#39;?&#39; + data, true);        } else {            // xhr.open(&#39;GET&#39;, url + &#39;?t=&#39; + random, true);            xhr.open(&#39;GET&#39;, url, true);        }        xhr.send();    } else if ( type.toUpperCase() == &#39;POST&#39; ) {        xhr.open(&#39;POST&#39;, url, true);        // 如果需要像 html 表单那样 POST 数据，请使用 setRequestHeader() 来添加 http 头。        xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);        xhr.send(data);    }    // 处理返回数据    xhr.onreadystatechange = function() {        if ( xhr.readyState == 4 ) {            if ( xhr.status == 200 ) {                success( xhr.responseText );            } else {                if ( failed ) {                    failed( xhr.status );                }            }        }    }}</code></pre></li><li><p>基于Promise封装的ajax函数</p><pre><code class="javascript">const getJSON = function( url ) {    const promise = new Promise( function( resolve, reject ) {        const handler = function() {            if ( this.readyState !== 4 ) {                return;            }            if ( this.status === 200 ) {                resolve(this.response);            } else {                reject(new Error(this.statusText));            }        };        const client = new XMLHttpRequest();        client.open(&quot;GET&quot;, url);        client.onreadystatechange = handler;        client.responseType = &quot;json&quot;;        client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);        client.send();    });    return promise;};</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>兼容IE8的方法函数</title>
      <link href="/2019/09/27/%E5%85%BC%E5%AE%B9IE8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95/"/>
      <url>/2019/09/27/%E5%85%BC%E5%AE%B9IE8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<!-- ## 兼容IE8的方法函数 --><ol><li><p>兼容IE8 数组的 forEach</p><pre><code class="javascript">if ( !Array.prototype.forEach ) {    Array.prototype.forEach = function forEach( callback, thisArg ) {        var T, k;        if ( this == null ) {               throw new TypeError( &quot;this is null or not defined&quot; );        }        var O = Object(this);        var len = O.length &gt;&gt;&gt; 0;         if ( typeof callback !== &quot;function&quot; ) {            throw new TypeError( callback + &quot; is not a function&quot; );        }        if ( arguments.length &gt; 1 ) {            T = thisArg;        }        k = 0;        while( k &lt; len ) {            var kValue;            if ( k in O ) {                kValue = O[ k ];                callback.call( T, kValue, k, O );            }            k++;        }    };}</code></pre></li><li><p>兼容IE8 数组的 indexOf</p><pre><code class="javascript">if ( !Array.prototype.indexOf ) {    Array.prototype.indexOf = function( elt /*, from*/ ) {        var len = this.length &gt;&gt;&gt; 0;        var from = Number( arguments[1] ) || 0;        from = (from &lt; 0)            ? Math.ceil(from)            : Math.floor(from);        if (from &lt; 0) from += len;        for ( ; from &lt; len; from++ ) {            if ( from in this &amp;&amp; this[from] === elt) return from;        }        return -1;    };}</code></pre></li><li><p>兼容bind函数</p><pre><code class="javascript">if ( !Function.prototype.bind ) {    Function.prototype.bind = function() {        if ( typeof this !== &#39;function&#39; ){            throw new TypeError(&#39;Function.prototype.bind - what is trying to be bound is not callable&#39;);        }        var _this = this;        var obj = arguments[0];        var ags = Array.prototype.slice.call( arguments, 1 );        return function() {            _this.apply( obj,ags );        };    };}</code></pre></li><li><p>兼容IE8的getElementsByClassName函数</p><pre><code class="javascript">if ( !document.getElementsByClassName ) {    document.getElementsByClassName = function ( className, element ) {        var children = ( element || document ).getElementsByTagName(&#39;*&#39;);        var elements = new Array();        for ( var i = 0; i &lt; children.length; i++ ) {            var child = children[i];            var classNames = child.className.split(&#39; &#39;);            for ( var j = 0; j &lt; classNames.length; j++ ) {                if ( classNames[j] == className ) {                    elements.push(child);                    break;                }            }        }        return elements;    };}</code></pre></li><li><p>兼容IE8的addEventListener函数</p><pre><code class="javascript">function addEventListener( ele,event,fn ){    if( ele.addEventListener ) {        ele.addEventListener( event, fn, false );    } else {        ele.attachEvent( &#39;on&#39;+event, fn.bind(ele) );    }}</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOMContentLoaded与load的区别</title>
      <link href="/2019/09/27/DOMContentLoaded%E5%92%8Cload%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/09/27/DOMContentLoaded%E5%92%8Cload%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<!-- ## DOMContentLoaded与load的区别 --><h3 id="onload事件"><a href="#onload事件" class="headerlink" title="onload事件"></a>onload事件</h3><p>onload事件所有的浏览器都支持，所以不需要考虑兼容性。</p><pre><code class="javascript">window.onload = function() {}</code></pre><h3 id="DOMContentLoaded事件"><a href="#DOMContentLoaded事件" class="headerlink" title="DOMContentLoaded事件"></a>DOMContentLoaded事件</h3><p>DOMContentLoaded不同的浏览器对其支持不同，所以在使用时，需要做不同浏览器的兼容。</p><ul><li><p>IE6、IE7不支持DOMContentLoaded，但支持onreadystatechange事件，该事件的目的是提供与文档或元素的加载状态有关的信息。</p></li><li><p>更低的IE还有个特有的方法doScroll，通过间隔调用：<code>document.docuemntElement.doScroll(&quot;left&quot;);</code></p><p>可以检测DOM是否加载完成。当页面未加载完成时，该方法会报错，知道doScroll不再报错时，就代表DOM加载完成了。该方法更接近DOMContentLoaded的实现。</p></li></ul><pre><code class="javascript">function ready( fn ) {    if ( docuemnt.addEventListener ) {        document.addEventListener(&#39;DOMContentLoaded&#39;, function() {            document.removeEventListener(&#39;DOMContentLoaded&#39;, arguments.callee, false);            fn();        }, false);    } else if ( document.attachEvent ) {        //确保当页面时在iframe中加载时，事件依旧会被安全触发        document.addachEvent(&#39;onreadystatechange&#39;, function() {            if ( document.readyState == &#39;complete&#39; ) {                document.detachEvent(&#39;onreadystatechange&#39;, arguments.callee);                fn();             }        });        //如果是IE且页面不再iframe中时，轮询调用doScroll方法检测DOM是否加载完毕        if ( document.documentElement.doScroll &amp;&amp; typeof window.frameElement === &#39;undefined&#39; ) {            try {                document.documentElement.doScroll(&#39;left&#39;);            }            catch( error ) {                return setTimeout( arguments.callee, 20 );            };            fn();        }    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>客户端存储</title>
      <link href="/2019/09/26/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8/"/>
      <url>/2019/09/26/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<!-- # 客户端存储 --><p>随着技术的发展、网速的提升，浏览器做的事情也越来越多，能实现的功能也越来越丰富。而传统的C/S架构也基本被B/S架构给替代。</p><p>此时传统的Cookie已经远远不能满足我们的需求了。于是WebSQL、HTML5中本地存储（LocalStorage、SessionStorage）、IndexedDB等便适时出现，让前端可以彻底的大展手脚。</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie在第一次与服务器通讯时由服务器设定并返回浏览器，之后浏览器的每一次请求都会在HTTP头部带上Cookie。一般情况下，我们每一次刷新页面或者点击链接跳转时Cookie都会被发到服务器用于验证我们的身份。服务器往往会在设置一个类似id的字段（一般会叫做sid）来作为身份的凭据。有时也会设置一些其他的内容储存在客户端中。最常见的应用就是当我们登录某个论坛或者网站之后，在一段时间内可以不用重复进行登录。</p><p>Cookie 与服务器交互的示意图<br><img src="http://qab0509yb.bkt.clouddn.com/Cookie%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BA%A4%E4%BA%92.png?e=1589437801&token=MIrZ7LQYfioElE2n_5z4EEnVUeHs-9w9ERfJRUG9:eB8EKQ8YSzvpFhS6SqP6tsTH_iw=" alt="Cookie与服务器交互"></p><p>Cookie中虽然可以存放信息，但一般情况下（尤其是现代前端开发）我们不会将其作为存放数据的主要手段。主要原因有以下几点。</p><ul><li><p>安全性：Cookie很容易被读取。因为本身就作为<code>document</code>的属性之一，我们在控制台通过<code>document.cookie</code>就能获取Cookie的内容。并且Cookie最终是以文件的形式存放在本地，name查看和修改就十分方便，这也是不建议存放敏感数据的原因。</p></li><li><p>传输性：由于Cookie是放在HTTP请求头中发出，因此在传输时会占用一定的带宽，所以过多的内容就会增加传输的负担。一般情况下不会建议Cookie的大小超过4KB。</p></li><li><p>易用性：虽然说Cookie是以<code>cookieName=Value;</code>这样的键值对的形式赋值。但本质上仍然是一个字符串，<code>typeof document.cookie</code>返回的是<code>string</code>。这也就意味着，我们在操作Cookie时实际上需要进行字符串操作。这与Web存储（LocalStorage、SessionStorage）的操作相比就要复杂多了。</p><p>Cookie的属性：</p><table><thead><tr><th>编号</th><th align="right">名称</th><th>作用</th></tr></thead><tbody><tr><td>1</td><td align="right">Name</td><td>表示 Cookie 中属性的名称。</td></tr><tr><td>2</td><td align="right">Value</td><td>对用上面 Name，表示 Cookie 中属性对应的值。</td></tr><tr><td>3</td><td align="right">Domain</td><td>表示可以访问此 Cookie 的域名。如上面 <code>.bilibili.com</code> 为顶级域名，下面的二级域名都可以访问此 Cookie，而 <code>.live.bilibili.com</code> 的 Cookie 则只有这个域名才能访问，其他二级域名是无法访问的</td></tr><tr><td>4</td><td align="right">Path</td><td>与 Domain 类似，指定允许访问的路径。如 <code>.bilibili.com/abc</code> 这样的页面。若允许所有页面访问，则为 <code>/</code>。</td></tr><tr><td>5</td><td align="right">Expires/Max-Age</td><td>表示该条 Cookie 的过期时间，当超过该时间时，Cookie 会自动失效。如果不设置，则默认为 Session，即浏览器关闭后就失效。</td></tr><tr><td>6</td><td align="right">Size</td><td>表示这一条 Cookie 的大小。</td></tr><tr><td>7</td><td align="right">HTTP</td><td>表示 Cookie 的 HTTPONLY 属性。若为 ture, 则在 HTTP 请求头中会带有此 Cookie，并且不能通过 <code>document.cookie</code> 来访问。</td></tr><tr><td>8</td><td align="right">Secure</td><td>用来设置该 Cookie 能否只通过 HTTPS 来进行传输。</td></tr><tr><td>9</td><td align="right">SameSite</td><td>定义 Cookie 如何跨域发送，用来防止 CSRF 攻击。是谷歌开发的一种安全机制，有 Strict 和 Lax 两种属性。目前在后端的支持度还不高，基本没有相关的 API 来操作（需要走更底层的操作）。</td></tr></tbody></table></li></ul><h3 id="Cookie的使用方法"><a href="#Cookie的使用方法" class="headerlink" title="Cookie的使用方法"></a>Cookie的使用方法</h3><h4 id="Cookie的写入"><a href="#Cookie的写入" class="headerlink" title="Cookie的写入"></a>Cookie的写入</h4><p>因为JavaScript自带了 <code>document.cookie</code> 的方法，我们可以直接通过 <code>document.cookie=&#39;name=value;&#39;</code> 的方法来写入Cookie。</p><pre><code class="javascript">    document.cookie = &#39;name=aye&#39;;    docuemnt.cookie = &#39;age=23&#39;;    docuemnt.cookie = &#39;userId=123; userName=aye&#39;;    document.cookie = &#39;str=&#39; + escape(&#39;I love JavaScript&#39;);</code></pre><p>我们刚才对<code>document.cookie</code>连续赋值之后，<code>age</code>并不会覆盖之前的<code>name</code>，而是会增加一条。如果要一次存储多个键值对，可以用分号加空格隔开。在Cookie的值中如果出现了分号、逗号、等号和空格需要用<code>escape()</code>函数进行编码，它能将一些特殊符号使用十六进制表示。当使用<code>escape()</code>编码后，在取值后需要使用<code>unescape()</code>进行解码才能获得原来的值。</p><h4 id="Cookie的读取"><a href="#Cookie的读取" class="headerlink" title="Cookie的读取"></a>Cookie的读取</h4><p>我们直接使用<code>document.cookie</code>来进行读取，不过这样只能获取整段的字符串。尽管cookie字符串的分隔符还算明显<code>;</code>和<code>=</code>，但处理起来还需要一些步骤。这时我们可以使用一些库，在MDN上已有封装好的库了。主要API的用法如下。</p><ul><li>写入 Cookie <code>docCookies.setItem(name, value[, end[, path[, domain[, secure]]]])</code> 其中 <code>name</code> 和 <code>value</code> 是必须的参数。剩下的参数为可选参数，含义可以参见上面表格。</li><li>读取 <code>docCookies.getItem(name)</code> 通过 <code>name</code> 来获取 Cookie 的值，若不存在则返回 <code>null</code>。注意这里获取的仍然是 <code>String</code> 类型的数据。</li><li>移除 <code>Cookie docCookies.removeItem(name[, path],domain)</code> 移除指定 <code>name</code> 的 Cookie。本质上是将过期时间设置成一个过去的时间，从而让 Cookie 失效。</li><li>检查 Cookie <code>docCookies.hasItem(name)</code> 检查一个 Cookie 是否存在，返回布尔类型的值。</li><li>列出全部 Cookie <code>docCookies.keys()</code> 列出所有可读的 Cookie 的数组。</li></ul><h4 id="Cookie的删除"><a href="#Cookie的删除" class="headerlink" title="Cookie的删除"></a>Cookie的删除</h4><p>Cookie 并没有提供删除的 API。但是我们可以通过设置 <code>max-age</code> 或者 <code>expires</code> 来让 Cookie 失效，从而达到删除的效果。</p><p><code>max-age</code> 和 <code>expires</code> 虽然在作用上是一样的，但是在实际的应用中，我们一般还是建议使用 <code>max-age</code>，主要的原因有下面几点。</p><ul><li><code>max-age</code> 为秒数，<code>expires</code> 为一个固定的 GMT 时间。而服务器与客户端可能会存在时间不同步的情况，因此就会引起问题。</li><li><code>max-age</code> 的时间从文档第一次被服务器记录就开始计算，更为准确。</li></ul><p>不过由于 <code>expires</code> 为 HTTP/1.0 中就已经存在了，对于遗留项目或需要向下兼容的项目，可能会用上。对于新的项目，还是建议采用 Cookie 或是其他代替技术。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>Cookie 作为最古老的客户端存储的手段陪伴着我们很多年了，但从实际使用来看也主要是用于一些属性的读写。即便在现在有许多代替技术的情况下也依旧在使用。不过由于 Cookie 的大小的限制、操作、安全性等问题，建议在做新项目的时候多考虑用其他技术来代替。</p><h3 id="Cookie-与-Session-的区别"><a href="#Cookie-与-Session-的区别" class="headerlink" title="Cookie 与 Session 的区别"></a>Cookie 与 Session 的区别</h3><p>Cookie和Session本质上没有区别。只是Cookie是放在客户端上的，而Session是记录在服务器上的，数据会更为安全。一般来说，Cookie会带着Session生成的Session id。两者都是用来记录用户的访问状态的。</p><ul><li>Cookie以文本文件格式存储在浏览器中，而session存储在服务端它存储了限制数据量。它只允许4kb它没有在cookie中保存多个变量。</li><li>cookie的存储限制了数据量，只允许4KB，而session是无限量的。</li><li>我们可以轻松访问cookie值但是我们无法轻松访问会话值，因此它更安全。</li><li>设置cookie时间可以使cookie过期。但是使用session-destory（），我们将会销毁会话。</li></ul><p>总结：如果我们需要经常登录一个站点时，最好用cookie来保存信息，要不然每次登陆都特别麻烦，如果对于需要安全性高的站点以及控制数据的能力时需要用Session效果更佳，当然我们也可以结合两者，使网站按照我们的想法进行运行。</p><h2 id="LocalStorage-SessionStorage"><a href="#LocalStorage-SessionStorage" class="headerlink" title="LocalStorage / SessionStorage"></a>LocalStorage / SessionStorage</h2><p>因为LocalStorage和SessionStorage在用法和存储时间外的特性上完全一样，后文全用LocalStorage来举例。</p><p>我们可以在 Can I use 上查看到，几乎所有主流的浏览器都支持了LocalStorage，IE也从8开始就支持了。</p><p>同为客户端存储，LocalStorage有哪些优势。</p><ul><li>存放大小：一般对于一个网站来说，LocalStorage 可以储存约 5MB 左右的数据，相较于 4KB 的 Cookie 来说，要打上许多。也基本可以满足我们日常网站的需求。</li><li>存储时间：LocalStorage 是永久储存在客户端上的，没有过期时间。而 SessionStorage 则是在浏览器关闭后销毁的，与不设置 <code>max-age</code>的 Cookie一样。</li><li>操作简便：LocalStorage 采用 <code>key</code>-<code>value</code> 的形式进行存储，并且提供了可以操作的 API，很方便我们查看操作某个属性。</li></ul><p>当然，任何技术也有局限性。对于LocalStorage来说，有以下几点：</p><ul><li>在隐身模式下（或隐私模式下），无法对 LocalStorage 进行操作，值是不可读取的。</li><li><code>key</code>-<code>value</code> 存储中的 <code>value</code> 只能是字符串。因此在存入 <code>String</code> 类型外的数据时，需要经过转换。尤其是当存入数组或者 JSON 等复杂结构的数据时需要使用<code>JSON.stringify</code> 方法，来保证数据的结构不会被破坏。</li><li>LocalStorage 的所有操作都是同步的，也就意味着会造成阻塞。因此在数据量大或者处理复杂时，会造成页面卡顿。</li></ul>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cookie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 查看端口，查看进程，关闭进程</title>
      <link href="/2019/09/26/Linux%E8%BF%9B%E7%A8%8B%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/09/26/Linux%E8%BF%9B%E7%A8%8B%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-查看端口，查看进程，关闭进程"><a href="#Linux-查看端口，查看进程，关闭进程" class="headerlink" title="Linux 查看端口，查看进程，关闭进程"></a>Linux 查看端口，查看进程，关闭进程</h2><p>查看进程xxxx的pid：</p><pre><code># ps -ef | grep xxxx</code></pre><p>查看端口12345的pid</p><pre><code># lsof -i:12345</code></pre><p>关闭pid为xxxx的进程</p><pre><code># kill -9 xxxx</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在CentOS下搭建Git服务器</title>
      <link href="/2019/09/25/%E5%AE%89%E8%A3%85git%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2019/09/25/%E5%AE%89%E8%A3%85git%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<!-- ## **在**CentOS下搭建git服务器 --><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><h4 id="第一步：安装git服务"><a href="#第一步：安装git服务" class="headerlink" title="第一步：安装git服务"></a>第一步：安装git服务</h4><p>【注】yum 源仓库里的 Git 版本更新不及时，最新版本的 Git 是1.8.3.1，但是官方最新版本已经到了 2.9.2。想要安装最新版本的 Git ，之恶能下载源码进行安装。</p><pre><code class="bash"># yum info git //查看 yum 源仓库的 Git 信息</code></pre><p>可以看出，截至目前，yum 源仓库中最新的 Git 版本才 1.8.3.1 ，而查看最新的 Git 发布版本，已经 2.9.2 了。</p><pre><code class="bash">// 依赖库安装# yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel# yum install gcc perl-ExtUtils-MakeMaker// 卸载低版本的 Git# yum remove git// 下载新版的 Git 源码包 （放在了 /usr/local/git 的目录下，git 是新建的目录）# cd git# wget https://github.com/git/git/archive/v2.9.2.tar.gz# tar -xzvf v2.9.2.tar.gz</code></pre><p>分别执行一下命令进行编译安装，编译过程可能比较漫长，请耐心等待完成。</p><pre><code class="bash"># cd git-2.9.2# make prefix=/usr/local/git all# make prefix=/usr/local/git install</code></pre><p>添加到环境变量</p><pre><code class="bash"># vim /etc/profile</code></pre><p>添加这一条： <code>export PATH=/usr/local/git/bin:$PATH</code></p><pre><code class="bash"># source /etc/profile    // 使配置立即生效# git --version        // 查看版本号</code></pre><p>将git设置为默认路径，不然后面克隆时会报错</p><pre><code class="bash"># ln -s /usr/local/git/bin/git-upload-pack /usr/bin/git-upload-pack# ln -s /usr/local/git/bin/git-receive-pack /usr/bin/git-receive-pack</code></pre><p>创建一个git用户组和用户，用来运行git服务</p><pre><code class="bash"># groupadd git# useradd git -g git# passwd git </code></pre><p>禁止该git用户使用shell登录系统（为了安全性，一般都禁止）</p><pre><code class="bash"># vim /etc/passwd</code></pre><p>找到类似下面的一行</p><pre><code>git:x:502:502::/home/git:/bin/bash</code></pre><p>改为</p><pre><code>git:x:502:502::/home/git:/usr/local/git/bin/git-shell</code></pre><p>保存并退出。</p><p>至此， git服务安装完成！</p><h4 id="第二步：配置远程仓库"><a href="#第二步：配置远程仓库" class="headerlink" title="第二步：配置远程仓库"></a>第二步：配置远程仓库</h4><p>创建一个空仓库</p><pre><code class="bash"># cd /home# mkdir git# cd git# git init --bare LearnProject.git</code></pre><p>到这里，空仓库已经创建成功，仓库的路径为：<code>/home/git/LearnProject.git</code></p><blockquote><p>通过 <code>git init --bare LearnProject.git</code> 建立的仓库是没有工作目录的，如需包含工作目录，请看注1。</p></blockquote><p>为刚刚创建的用户git赋予权限</p><pre><code class="bash">//chown -R 用户名:组名 文件# chown -R git:git LearnProject.git</code></pre><h4 id="第三步：打开-RSA-认证"><a href="#第三步：打开-RSA-认证" class="headerlink" title="第三步：打开 RSA 认证"></a>第三步：打开 RSA 认证</h4><p>进入 <code>/etc/ssh</code>  目录，编辑 sshd_config</p><pre><code class="bash"># cd /etc/ssh# vim sshd_config</code></pre><p>将下面几个的注释解开（带#为注释）</p><pre><code>RSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys</code></pre><p>保存完成后，重启sshd服务</p><pre><code class="bash"># /etc/rc.d/init.d/sshd restart</code></pre><p>如果运行上述命令出现以下错误：</p><pre><code>-bash: /etc/rc.d/init.d/sshd: No such file or directory</code></pre><p>可以尝试以下命令：</p><pre><code class="bash"># service sshd restart</code></pre><p>或者</p><pre><code class="bash"># systemctl restart sshd</code></pre><p>至此，服务器端git配置完成。</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><h4 id="第一步：配置git"><a href="#第一步：配置git" class="headerlink" title="第一步：配置git"></a>第一步：配置git</h4><h5 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h5><p>傻瓜式安装</p><h5 id="打开git-bash创建git使用者"><a href="#打开git-bash创建git使用者" class="headerlink" title="打开git bash创建git使用者"></a>打开git bash创建git使用者</h5><pre><code class="git">git config --global user.name &quot;姓名&quot;git config --global user.email &quot;邮箱&quot;</code></pre><h5 id="创建与服务器通讯的密钥"><a href="#创建与服务器通讯的密钥" class="headerlink" title="创建与服务器通讯的密钥"></a>创建与服务器通讯的密钥</h5><p>在git bash中，输入一下命令，为自己的邮箱创建一个密钥</p><pre><code class="git">ssh-keygen -t rsa -C &quot;邮箱&quot;</code></pre><p>一路enter下去</p><pre><code>Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/***/.ssh/id_rsa):Created directory &#39;/c/Users/***/.ssh&#39;.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /c/Users/***/.ssh/id_rsa.Your public key has been saved in /c/Users/***/.ssh/id_rsa.pub.The key fingerprint is:SHA256:F0NzRZYN3zMR5oGeOxuQE5LBwoKsEC8Un/0cl4SWk44 ***@******The key&#39;s randomart image is:+---[RSA 2048]----+|.+o . . =o= .o*O.||o..oo. O.=.+ o+.=||o oo .=.oo+ + .+o|| o   Eo.o  * o  o||       oS . o .  ||         .   +   ||              +  ||             .   ||                 |+----[SHA256]-----+</code></pre><p>这时候，系统已经为我们创建了一个公钥和密钥，id_rsa是密钥，不能告诉任何人，id_rsa.pub是公钥，可以公开。</p><h5 id="将本地的公钥添加到服务器上"><a href="#将本地的公钥添加到服务器上" class="headerlink" title="将本地的公钥添加到服务器上"></a>将本地的公钥添加到服务器上</h5><ul><li>通过客户端命令行将本地公钥添加进远程服务器中</li></ul><p>在gitbash下，输入一下命令</p><pre><code class="bash">ssh git@IP地址 &#39;cat &gt;&gt; .ssh/authorized_keys&#39; &lt; ~/.ssh/id_rsa.pub</code></pre><ul><li>手动将公钥添加到服务器中</li></ul><p>找到id_rsa.pub文件，用编辑器打开，全选复制。</p><p>在服务器端，将复制的内容粘贴到authorized_keys文件中</p><p><strong>注意文件路径：<code>/root/.ssh/authorized_keys</code></strong></p><pre><code class="bash"># vim /root/.ssh/authorized_keys</code></pre><p>通过以上两种方法，我们就将本地的公钥添加进服务器中了。如果发现该目录下没有 .ssh 文件，我们可以手动创建一个，并添加一个 authorized_keys 。</p><h4 id="第二步：克隆远程仓库cd-vim"><a href="#第二步：克隆远程仓库cd-vim" class="headerlink" title="第二步：克隆远程仓库cd /vim"></a>第二步：克隆远程仓库cd /vim</h4><p>创建一个用于本地的git仓库文件夹，在文件夹内克隆远程仓库</p><pre><code class="bash">git clone git@IP地址：端口/home/git/LearnProject.gitgit clone ssh://root@IP地址/home/git/LearnProject.git</code></pre><p>这时候，bash会提示你克隆的仓库是空的</p><pre><code>Cloning into &#39;LearnProject&#39;...warning: You appear to have cloned an empty repository.</code></pre><blockquote><p>如果想使用 http 方式克隆，参考 <a href="https://blog.csdn.net/name_is_wl/article/details/86705032" target="_blank" rel="noopener">使用nginx搭建http 访问的git服务器</a></p></blockquote><p>至此，我们完成了远程仓库的克隆。</p><h4 id="第三步：push-pull项目"><a href="#第三步：push-pull项目" class="headerlink" title="第三步：push/pull项目"></a>第三步：push/pull项目</h4><p>做完以上服务器端/客户端各两步的内容，你的本地git已经可以和git服务器进行通信了，此时我们可以进行常规的项目push和pull了。</p><h4 id="注1：建立包含工作目录的仓库"><a href="#注1：建立包含工作目录的仓库" class="headerlink" title="注1：建立包含工作目录的仓库"></a>注1：建立包含工作目录的仓库</h4><h5 id="post-receive-实现自动同步到站点目录"><a href="#post-receive-实现自动同步到站点目录" class="headerlink" title="post-receive 实现自动同步到站点目录"></a><code>post-receive</code> 实现自动同步到站点目录</h5><p>如果你是用 <code>git init --bare LernProject.git</code> 建立的仓库，该仓库是没有工作目录的。</p><p>我们需要在该仓库的 hooks下，创建 post-receive 文件。</p><pre><code># cd LearnProject.git# cd hooks# vim post-receive</code></pre><p>文件内容为：</p><pre><code>#!/bin/bashgit --work-tree=/home/www checkout -f</code></pre><p>保存退出后，设置权限</p><pre><code># chown git:git post-receive //将该文件用户及用户组都设置成git# chmod +x post-receive //由于该文件是一个shell文件，应设置为可执行权限</code></pre><h5 id="创建支持工作目录的远程仓库"><a href="#创建支持工作目录的远程仓库" class="headerlink" title="创建支持工作目录的远程仓库"></a>创建支持工作目录的远程仓库</h5><pre><code># git init &lt;仓库名&gt; # git config receive.denyCurrentBranch ignore //设置允许远程接收文件</code></pre><p>在远程仓库 <code>post-receive</code> 钩子文件中添加自动更新工作目录内容</p><pre><code>WORK_TREE=&#39;../&#39;git --work-tree=&quot;${WORK_TREE}&quot; reset --hard</code></pre><p>保存退出后，设置权限，同上文。</p><h4 id="注2：git如何解决The-authenticity-of-host-can’t-be-established"><a href="#注2：git如何解决The-authenticity-of-host-can’t-be-established" class="headerlink" title="注2：git如何解决The authenticity of host can’t be established"></a>注2：git如何解决The authenticity of host can’t be established</h4><p>新生成的密钥，git clone或者push的时候，有可能会报下面的错误：</p><pre><code>The authenticity of host &#39;148.70.59.85 (148.70.59.85)&#39; can&#39;t be established.ECDSA key fingerprint is SHA256:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.</code></pre><p>文件夹内少了一个konwn_hosts文件，本来密钥文件应该是三个，现在只有两个，便报了这样的错误，此时输入yes回车之后，生成了缺少的konwn_hosts文件，便可解决这个问题。</p><pre><code class="bash">Are you sure you want to continue connecting (yes/no)?  yesWarning: Permanently added &#39;gitee.com,xxx.xxx.xxx.xxx&#39; (ECDSA) to the list of known hosts.ssh_packet_read: Connection closed</code></pre><p>【参考】</p><p><a href="https://blog.csdn.net/w252064/article/details/82691343" target="_blank" rel="noopener">Centos7搭建git服务器端</a></p><p><a href="https://blog.csdn.net/bbcckkl/article/details/81634761" target="_blank" rel="noopener">Git丨在CentOS下搭建私有的git服务器</a></p><p><a href="https://blog.csdn.net/li1107068356/article/details/53814993" target="_blank" rel="noopener">搭建Git服务器遇到的那些坑</a></p><p><a href="https://baijiahao.baidu.com/s?id=1606669351803311743&wfr=spider&for=pc" target="_blank" rel="noopener">git clone 异常 fatal: Could not read from remote repository</a></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery的类数组对象结构</title>
      <link href="/2019/09/25/%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84/"/>
      <url>/2019/09/25/%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<!-- ## jQuery的类数组对象结构 --><p>jQuery为什么能像数组一样操作，通过对象get方法或者直接通过下标0索引就能转成DOM对象。</p><p>首先jQuery的入口都是统一的$，通过传递参数的不同，实现了9种方法的重载：</p><pre><code class="javascript">jQuery([selector, [context]])jQuery(element)jQuery(elementArray)jQuery(object)jQuery(jQuery object)jQuery(html, [ownerDocument])jQuery(html, [attributes])jQuery()jQuery(callback)</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery立即调用表达式</title>
      <link href="/2019/09/25/%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/09/25/%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<!-- ## 立即调用表达式 --><pre><code class="javascript">;(function(global, factory){    factory(global);}(typeof window !== &quot;undefined&quot; ? window : this, function(window, noGlobal) {    var jQuery = function (selector, context) {        return new jQuery.fn.init(selector, context);    }    jQuery.fn = jQuery.prototype = {};    return jQuery;}));</code></pre><p>任何库与框架设计的第一个要点就是<strong>解决命名空间与变量污染的问题</strong>。jQuery就是利用了JavaScript函数作用域的特性，采用<strong>立即调用表达式</strong>包裹了自身的方法来解决这个问题。</p><p>jQuery的立即调用函数表达式的写法有三种：</p><p><strong>写法1：</strong></p><pre><code class="javascript">(function(window, factory) {    factory(window);}(this, function() {    return function() {        //jQuery的调用    }}))</code></pre><p>可以看出上面的代码中嵌套了2个函数，而且把一个函数作为参数传递到另一个函数中并且执行，这种方法有点复杂，我们简化一下写法：</p><p><strong>写法2：</strong></p><pre><code class="javascript">var factory = function() {    return function() {        //执行方法    }}var jQuery = factory();</code></pre><p>上面的代码效果和方法1是等同的，但是这个factory有点变成了简单的工厂方法模式，需要自己调用，不像是一个单例的jQuery类，所以我们需要改成“自执行”，而不是另外调用。</p><p><strong>写法3：</strong></p><pre><code>(function(window, undefined) {    var jQuery = function() {}    // ...    window.jQuery = window.$ = jQuery;})(window);</code></pre><p>从上面的代码可看出，自动初始化这个函数，让其只构建一次。详细说一些这种写法的优势：</p><ol><li>window和undefined都是为了减少变量查找所经过的scope作用域。当window通过传递给闭包内部之后，在闭包内部使用它的时候，可以把它当成一个局部变量，显然比原先在window scope下查找的时候要快一些。</li><li>undefined也是同样的道理，其实这个undefined并不是JavaScript数据类型的undefined，而是一个普普通通的变量名。只是因为没给它传递值，它的值就是undefined，undefined并不是JavaScript的保留字。</li></ol><p>为什么要传递undefined？</p><p><strong>JavaScript中的undefined并不是作为关键字，因此可以允许用户对其赋值。</strong></p><p>总结：全局变量是魔鬼，匿名函数可以有效地保证在页面上写入JavaScript，而不会造成全局变量的污染，通过小括号，让其加载的时候立即初始化，这样就形成了一个单例模式的效果从而只会执行一次。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
